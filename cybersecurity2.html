<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybersecurity - Chapter 2: Authentication & Authorization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }
        .content {
            padding: 40px;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            color: #4285f4;
            border-bottom: 3px solid #4285f4;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        .section h3 {
            color: #34a853;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .important {
            background: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }
        .auth-flow {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .auth-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
            border-left: 4px solid #4285f4;
        }
        .auth-card h4 {
            color: #4285f4;
            margin: 0 0 10px 0;
        }
        .auth-card p {
            margin: 0;
            color: #666;
            font-size: 0.9em;
        }
        .jwt-diagram {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .jwt-parts {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        .jwt-part {
            background: white;
            border: 1px solid #bbdefb;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }
        .jwt-part h5 {
            color: #1976d2;
            margin: 0 0 8px 0;
        }
        .jwt-part p {
            margin: 0;
            color: #666;
            font-size: 0.85em;
        }
        .oauth-flow {
            background: #f3e5f5;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .oauth-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .oauth-step {
            background: white;
            border: 1px solid #ce93d8;
            border-radius: 6px;
            padding: 12px;
            font-size: 0.9em;
        }
        .oauth-step strong {
            color: #7b1fa2;
        }
        .security-practices {
            background: #e8f5e9;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .practice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .practice-item {
            background: white;
            border: 1px solid #c8e6c9;
            border-radius: 6px;
            padding: 15px;
        }
        .practice-item h5 {
            color: #2e7d32;
            margin: 0 0 8px 0;
        }
        .practice-item p {
            margin: 0;
            color: #666;
            font-size: 0.85em;
        }
        .vulnerability-alert {
            background: #ffebee;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .vulnerability-alert h4 {
            color: #c62828;
            margin: 0 0 15px 0;
        }
        .vulnerability-item {
            background: white;
            border: 1px solid #ffcdd2;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            font-size: 0.9em;
        }
        .quiz-section {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
        }
        .quiz-section h3 {
            color: #333;
            margin-bottom: 20px;
        }
        .quiz-question {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .quiz-question h4 {
            color: #4285f4;
            margin: 0 0 15px 0;
        }
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quiz-option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .quiz-option:hover {
            background: #e3f2fd;
            border-color: #4285f4;
        }
        .quiz-option.correct {
            background: #e8f5e9;
            border-color: #34a853;
        }
        .quiz-option.incorrect {
            background: #ffebee;
            border-color: #dc3545;
        }
        .quiz-result {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            display: none;
        }
        .quiz-result.correct {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .quiz-result.incorrect {
            background: #ffebee;
            color: #c62828;
        }
        .navigation {
            background: linear-gradient(135deg, #fff8e1 0%, #ffcc02 100%);
            border: 2px solid #ff9800;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }
        .nav-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .nav-btn {
            background: #4285f4;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }
        .nav-btn:hover {
            background: #3367d6;
        }
        .nav-btn.secondary {
            background: #34a853;
        }
        .nav-btn.secondary:hover {
            background: #2e7d32;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        .comparison-table th {
            background: #f8f9fa;
            color: #333;
            font-weight: 600;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .access-control {
            background: #fff3e0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .access-control h4 {
            color: #e65100;
            margin: 0 0 15px 0;
        }
        .access-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .access-type {
            background: white;
            border: 1px solid #ffcc02;
            border-radius: 6px;
            padding: 15px;
        }
        .access-type h5 {
            color: #e65100;
            margin: 0 0 8px 0;
        }
        .access-type p {
            margin: 0;
            color: #666;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Cybersecurity</h1>
            <div class="subtitle">Chapter 2: Authentication & Authorization</div>
        </div>

        <div class="content">
            <div class="section">
                <h2>üîë Authentication vs Authorization</h2>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Authentication</th>
                            <th>Authorization</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Verifying user identity</td>
                            <td>Determining user permissions</td>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Who are you?</td>
                            <td>What can you do?</td>
                        </tr>
                        <tr>
                            <td><strong>Examples</strong></td>
                            <td>Login, password, biometrics</td>
                            <td>Role-based access, permissions</td>
                        </tr>
                        <tr>
                            <td><strong>Security Focus</strong></td>
                            <td>Identity verification</td>
                            <td>Access control</td>
                        </tr>
                    </tbody>
                </table>

                <div class="highlight">
                    <strong>Security Principle:</strong>
                    <p>Authentication answers "Who are you?" while Authorization answers "What are you allowed to do?" Both are essential for secure systems, but they serve different purposes in the security model.</p>
                </div>
            </div>

            <div class="section">
                <h2>üõ°Ô∏è Session Management</h2>

                <div class="auth-flow">
                    <div class="auth-card">
                        <h4>Session Creation</h4>
                        <p>User provides valid credentials ‚Üí Server creates session ‚Üí Session ID generated ‚Üí Session stored securely</p>
                    </div>

                    <div class="auth-card">
                        <h4>Session Validation</h4>
                        <p>Client sends session ID ‚Üí Server validates session ‚Üí Grants access if valid ‚Üí Updates session expiry</p>
                    </div>

                    <div class="auth-card">
                        <h4>Session Termination</h4>
                        <p>User logs out ‚Üí Server destroys session ‚Üí Clear session data ‚Üí Invalidate session ID</p>
                    </div>
                </div>

                <h3>Secure Session Implementation</h3>
                <div class="code-block">
                    <pre><code>// Node.js Express - Secure Session Management
const session = require('express-session');
const RedisStore = require('connect-redis')(session);

app.use(session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: process.env.NODE_ENV === 'production', // HTTPS only
        httpOnly: true, // Prevent XSS access
        maxAge: 30 * 60 * 1000, // 30 minutes
        sameSite: 'strict' // CSRF protection
    },
    name: 'custom.sid' // Change default session name
}));

// Session validation middleware
function requireAuth(req, res, next) {
    if (!req.session.userId) {
        return res.status(401).json({ error: 'Authentication required' });
    }

    // Check session expiry
    if (req.session.cookie.expires < new Date()) {
        req.session.destroy();
        return res.status(401).json({ error: 'Session expired' });
    }

    next();
}

// Logout endpoint
app.post('/logout', (req, res) => {
    req.session.destroy((err) => {
        if (err) {
            return res.status(500).json({ error: 'Logout failed' });
        }
        res.clearCookie('custom.sid');
        res.json({ message: 'Logged out successfully' });
    });
});</code></pre>
                </div>

                <div class="important">
                    <strong>Session Security Best Practices:</strong>
                    <ul>
                        <li>Use secure, random session IDs (at least 128 bits)</li>
                        <li>Implement session timeout and automatic logout</li>
                        <li>Store sessions in secure server-side storage (Redis, database)</li>
                        <li>Use HttpOnly and Secure cookie flags</li>
                        <li>Regenerate session ID after login</li>
                        <li>Implement concurrent session limits</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>üé´ JSON Web Tokens (JWT)</h2>

                <div class="jwt-diagram">
                    <h4>JWT Structure</h4>
                    <div class="jwt-parts">
                        <div class="jwt-part">
                            <h5>Header</h5>
                            <p>Algorithm & token type</p>
                            <code>{"alg":"HS256","typ":"JWT"}</code>
                        </div>
                        <div class="jwt-part">
                            <h5>Payload</h5>
                            <p>User data & claims</p>
                            <code>{"userId":123,"role":"admin"}</code>
                        </div>
                        <div class="jwt-part">
                            <h5>Signature</h5>
                            <p>Verifies token integrity</p>
                            <code>HMACSHA256(base64(header)+"."+base64(payload), secret)</code>
                        </div>
                    </div>
                </div>

                <h3>JWT Implementation</h3>
                <div class="code-block">
                    <pre><code>// Node.js - JWT Authentication
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// Generate JWT token
function generateToken(user) {
    return jwt.sign(
        {
            userId: user.id,
            email: user.email,
            role: user.role
        },
        process.env.JWT_SECRET,
        {
            expiresIn: '1h', // Token expires in 1 hour
            issuer: 'your-app',
            audience: 'your-users'
        }
    );
}

// Verify JWT token middleware
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid or expired token' });
        }
        req.user = user;
        next();
    });
}

// Login endpoint
app.post('/login', async (req, res) => {
    const { email, password } = req.body;

    // Find user and verify password
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate tokens
    const accessToken = generateToken(user);
    const refreshToken = jwt.sign(
        { userId: user.id },
        process.env.JWT_REFRESH_SECRET,
        { expiresIn: '7d' }
    );

    // Store refresh token securely
    await Token.create({ userId: user.id, token: refreshToken });

    res.json({
        accessToken,
        refreshToken,
        user: { id: user.id, email: user.email, role: user.role }
    });
});

// Refresh token endpoint
app.post('/refresh', async (req, res) => {
    const { refreshToken } = req.body;

    if (!refreshToken) {
        return res.status(401).json({ error: 'Refresh token required' });
    }

    try {
        const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
        const storedToken = await Token.findOne({
            userId: decoded.userId,
            token: refreshToken
        });

        if (!storedToken) {
            return res.status(403).json({ error: 'Invalid refresh token' });
        }

        const user = await User.findById(decoded.userId);
        const newAccessToken = generateToken(user);

        res.json({ accessToken: newAccessToken });
    } catch (err) {
        res.status(403).json({ error: 'Invalid refresh token' });
    }
});</code></pre>
                </div>

                <div class="important">
                    <strong>JWT Security Considerations:</strong>
                    <ul>
                        <li>Use strong, unique secrets for signing</li>
                        <li>Implement token expiration (short-lived access tokens)</li>
                        <li>Store tokens securely (httpOnly cookies for web apps)</li>
                        <li>Use refresh tokens for long-term sessions</li>
                        <li>Validate token claims on the server</li>
                        <li>Implement token blacklisting for logout</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>üîó OAuth 2.0</h2>

                <div class="oauth-flow">
                    <h4>OAuth 2.0 Authorization Code Flow</h4>
                    <div class="oauth-steps">
                        <div class="oauth-step">
                            <strong>1. Authorization Request:</strong> User clicks "Login with Google" ‚Üí Redirected to Google with client_id, redirect_uri, scope
                        </div>
                        <div class="oauth-step">
                            <strong>2. User Consent:</strong> User logs in to Google ‚Üí Reviews permissions ‚Üí Grants consent
                        </div>
                        <div class="oauth-step">
                            <strong>3. Authorization Code:</strong> Google redirects back with authorization code
                        </div>
                        <div class="oauth-step">
                            <strong>4. Token Exchange:</strong> App exchanges code for access token using client_secret
                        </div>
                        <div class="oauth-step">
                            <strong>5. API Access:</strong> App uses access token to fetch user data from Google APIs
                        </div>
                    </div>
                </div>

                <h3>OAuth 2.0 Implementation</h3>
                <div class="code-block">
                    <pre><code>// Node.js - OAuth 2.0 with Google
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

// Configure Google OAuth strategy
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: '/auth/google/callback'
}, async (accessToken, refreshToken, profile, done) => {
    try {
        // Find or create user
        let user = await User.findOne({ googleId: profile.id });

        if (!user) {
            user = await User.create({
                googleId: profile.id,
                email: profile.emails[0].value,
                name: profile.displayName,
                avatar: profile.photos[0].value
            });
        }

        done(null, user);
    } catch (err) {
        done(err, null);
    }
}));

// Serialize user for session
passport.serializeUser((user, done) => {
    done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
    try {
        const user = await User.findById(id);
        done(null, user);
    } catch (err) {
        done(err, null);
    }
});

// Routes
app.get('/auth/google',
    passport.authenticate('google', {
        scope: ['profile', 'email']
    })
);

app.get('/auth/google/callback',
    passport.authenticate('google', { failureRedirect: '/login' }),
    (req, res) => {
        // Successful authentication
        res.redirect('/dashboard');
    }
);

app.get('/logout', (req, res) => {
    req.logout();
    res.redirect('/');
});

// Protected route
app.get('/profile', requireAuth, (req, res) => {
    res.json({
        user: {
            id: req.user.id,
            name: req.user.name,
            email: req.user.email
        }
    });
});</code></pre>
                </div>

                <div class="highlight">
                    <strong>OAuth 2.0 Grant Types:</strong>
                    <ul>
                        <li><strong>Authorization Code:</strong> Most secure, for web applications</li>
                        <li><strong>Implicit:</strong> For client-side applications (deprecated)</li>
                        <li><strong>Resource Owner Password:</strong> Direct username/password exchange</li>
                        <li><strong>Client Credentials:</strong> For machine-to-machine authentication</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>üîí Password Security</h2>

                <div class="security-practices">
                    <h4>Password Security Best Practices</h4>
                    <div class="practice-grid">
                        <div class="practice-item">
                            <h5>Strong Hashing</h5>
                            <p>Use bcrypt, scrypt, or Argon2 with appropriate work factors. Never use MD5 or SHA-256 directly for passwords.</p>
                        </div>

                        <div class="practice-item">
                            <h5>Password Policies</h5>
                            <p>Enforce minimum length (12+ characters), complexity requirements, and prevent common passwords.</p>
                        </div>

                        <div class="practice-item">
                            <h5>Password Reset</h5>
                            <p>Use secure reset tokens with expiration, send via email only, and require current password verification.</p>
                        </div>

                        <div class="practice-item">
                            <h5>Account Lockout</h5>
                            <p>Implement progressive delays and account lockout after failed attempts to prevent brute force attacks.</p>
                        </div>

                        <div class="practice-item">
                            <h5>Password Storage</h5>
                            <p>Store only hashed passwords, use unique salts per password, and implement proper key management.</p>
                        </div>

                        <div class="practice-item">
                            <h5>Password History</h5>
                            <p>Prevent reuse of previous passwords and maintain password history for compliance.</p>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <pre><code>// Secure password implementation
const bcrypt = require('bcrypt');
const crypto = require('crypto');

class PasswordService {
    static async hashPassword(password) {
        const saltRounds = 12; // Increase for better security
        return await bcrypt.hash(password, saltRounds);
    }

    static async verifyPassword(password, hashedPassword) {
        return await bcrypt.compare(password, hashedPassword);
    }

    static generateResetToken() {
        return crypto.randomBytes(32).toString('hex');
    }

    static validatePasswordStrength(password) {
        const minLength = 12;
        const hasUpperCase = /[A-Z]/.test(password);
        const hasLowerCase = /[a-z]/.test(password);
        const hasNumbers = /\d/.test(password);
        const hasSpecialChars = /[!@#$%^&*(),.?":{}|<>]/.test(password);

        if (password.length < minLength) {
            return { valid: false, message: 'Password must be at least 12 characters' };
        }

        if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChars) {
            return { valid: false, message: 'Password must contain uppercase, lowercase, numbers, and special characters' };
        }

        return { valid: true };
    }
}

// Usage in authentication
async function registerUser(email, password) {
    // Validate password strength
    const validation = PasswordService.validatePasswordStrength(password);
    if (!validation.valid) {
        throw new Error(validation.message);
    }

    // Check if password is in common passwords list
    if (await isCommonPassword(password)) {
        throw new Error('Password is too common');
    }

    // Hash password
    const hashedPassword = await PasswordService.hashPassword(password);

    // Store user
    const user = await User.create({
        email,
        password: hashedPassword,
        passwordChangedAt: new Date()
    });

    return user;
}</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üîê Multi-Factor Authentication (MFA)</h2>

                <div class="highlight">
                    <strong>MFA Benefits:</strong>
                    <ul>
                        <li><strong>Enhanced Security:</strong> Requires multiple verification methods</li>
                        <li><strong>Phishing Protection:</strong> Even stolen passwords aren't enough</li>
                        <li><strong>Compliance:</strong> Required by many security standards</li>
                        <li><strong>User Trust:</strong> Demonstrates security commitment</li>
                        <li><strong>Account Recovery:</strong> Backup authentication methods</li>
                    </ul>
                </div>

                <h3>MFA Implementation with TOTP</h3>
                <div class="code-block">
                    <pre><code>// Node.js - TOTP MFA Implementation
const speakeasy = require('speakeasy');
const qrcode = require('qrcode');

// Generate MFA secret for user
function generateMFASecret(userId) {
    const secret = speakeasy.generateSecret({
        name: `YourApp (${userId})`,
        issuer: 'YourApp'
    });

    return {
        secret: secret.base32,
        otpauthUrl: secret.otpauth_url
    };
}

// Generate QR code for authenticator app
async function generateQRCode(otpauthUrl) {
    return await qrcode.toDataURL(otpauthUrl);
}

// Verify TOTP token
function verifyTOTP(token, secret) {
    return speakeasy.totp.verify({
        secret: secret,
        encoding: 'base32',
        token: token,
        window: 2 // Allow 2 time steps (30 seconds each)
    });
}

// Setup MFA endpoint
app.post('/mfa/setup', async (req, res) => {
    const userId = req.user.id;

    const { secret, otpauthUrl } = generateMFASecret(userId);
    const qrCodeUrl = await generateQRCode(otpauthUrl);

    // Store secret temporarily (don't save until verified)
    await TempMFASecret.create({
        userId,
        secret,
        expiresAt: new Date(Date.now() + 10 * 60 * 1000) // 10 minutes
    });

    res.json({
        secret: secret,
        qrCodeUrl,
        message: 'Scan QR code with authenticator app'
    });
});

// Verify and enable MFA
app.post('/mfa/verify', async (req, res) => {
    const userId = req.user.id;
    const { token } = req.body;

    const tempSecret = await TempMFASecret.findOne({
        userId,
        expiresAt: { $gt: new Date() }
    });

    if (!tempSecret) {
        return res.status(400).json({ error: 'MFA setup expired' });
    }

    const isValid = verifyTOTP(token, tempSecret.secret);
    if (!isValid) {
        return res.status(400).json({ error: 'Invalid token' });
    }

    // Enable MFA for user
    await User.findByIdAndUpdate(userId, {
        mfaEnabled: true,
        mfaSecret: tempSecret.secret
    });

    // Clean up temp secret
    await TempMFASecret.deleteOne({ _id: tempSecret._id });

    res.json({ message: 'MFA enabled successfully' });
});

// Login with MFA
app.post('/login', async (req, res) => {
    const { email, password, mfaToken } = req.body;

    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(401).json({ error: 'Invalid credentials' });
    }

    if (user.mfaEnabled) {
        if (!mfaToken) {
            return res.status(400).json({
                error: 'MFA token required',
                requiresMFA: true
            });
        }

        const isValid = verifyTOTP(mfaToken, user.mfaSecret);
        if (!isValid) {
            return res.status(401).json({ error: 'Invalid MFA token' });
        }
    }

    const token = generateToken(user);
    res.json({ token, user: sanitizeUser(user) });
});</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üé≠ Access Control</h2>

                <div class="access-control">
                    <h4>Access Control Models</h4>
                    <div class="access-types">
                        <div class="access-type">
                            <h5>Role-Based Access Control (RBAC)</h5>
                            <p>Permissions assigned based on user roles. Users have roles like 'admin', 'editor', 'viewer' with associated permissions.</p>
                        </div>

                        <div class="access-type">
                            <h5>Attribute-Based Access Control (ABAC)</h5>
                            <p>Access decisions based on attributes of user, resource, action, and environment. More flexible than RBAC.</p>
                        </div>

                        <div class="access-type">
                            <h5>Discretionary Access Control (DAC)</h5>
                            <p>Resource owners control access to their resources. Users can grant permissions to other users.</p>
                        </div>

                        <div class="access-type">
                            <h5>Mandatory Access Control (MAC)</h5>
                            <p>Access based on security labels and clearance levels. Used in high-security environments.</p>
                        </div>
                    </div>
                </div>

                <h3>RBAC Implementation</h3>
                <div class="code-block">
                    <pre><code>// Role-Based Access Control Implementation
const ROLES = {
    ADMIN: 'admin',
    EDITOR: 'editor',
    VIEWER: 'viewer'
};

const PERMISSIONS = {
    CREATE_POST: 'create_post',
    EDIT_POST: 'edit_post',
    DELETE_POST: 'delete_post',
    PUBLISH_POST: 'publish_post',
    MANAGE_USERS: 'manage_users'
};

// Role permissions mapping
const ROLE_PERMISSIONS = {
    [ROLES.ADMIN]: [
        PERMISSIONS.CREATE_POST,
        PERMISSIONS.EDIT_POST,
        PERMISSIONS.DELETE_POST,
        PERMISSIONS.PUBLISH_POST,
        PERMISSIONS.MANAGE_USERS
    ],
    [ROLES.EDITOR]: [
        PERMISSIONS.CREATE_POST,
        PERMISSIONS.EDIT_POST,
        PERMISSIONS.PUBLISH_POST
    ],
    [ROLES.VIEWER]: [
        // No permissions - read-only access
    ]
};

class AccessControl {
    static hasPermission(user, permission) {
        if (!user || !user.role) return false;

        const userPermissions = ROLE_PERMISSIONS[user.role] || [];
        return userPermissions.includes(permission);
    }

    static requirePermission(permission) {
        return (req, res, next) => {
            if (!this.hasPermission(req.user, permission)) {
                return res.status(403).json({
                    error: 'Insufficient permissions'
                });
            }
            next();
        };
    }

    static hasAnyPermission(user, permissions) {
        return permissions.some(permission =>
            this.hasPermission(user, permission)
        );
    }

    static hasAllPermissions(user, permissions) {
        return permissions.every(permission =>
            this.hasPermission(user, permission)
        );
    }
}

// Usage in routes
app.post('/posts',
    authenticateToken,
    AccessControl.requirePermission(PERMISSIONS.CREATE_POST),
    async (req, res) => {
        // Create post logic
    }
);

app.delete('/posts/:id',
    authenticateToken,
    AccessControl.requirePermission(PERMISSIONS.DELETE_POST),
    async (req, res) => {
        // Delete post logic
    }
);

// Advanced permission check
app.put('/posts/:id/publish',
    authenticateToken,
    (req, res, next) => {
        if (!AccessControl.hasAnyPermission(req.user, [
            PERMISSIONS.PUBLISH_POST,
            PERMISSIONS.ADMIN
        ])) {
            return res.status(403).json({ error: 'Cannot publish posts' });
        }
        next();
    },
    async (req, res) => {
        // Publish post logic
    }
);</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üö® Common Authentication Vulnerabilities</h2>

                <div class="vulnerability-alert">
                    <h4>Critical Authentication Vulnerabilities</h4>
                    <div class="vulnerability-item">
                        <strong>Broken Authentication:</strong> Flaws in session management, password recovery, or authentication mechanisms
                    </div>
                    <div class="vulnerability-item">
                        <strong>Session Fixation:</strong> Attacker sets victim's session ID before authentication
                    </div>
                    <div class="vulnerability-item">
                        <strong>Weak Password Policies:</strong> Allowing short, common, or easily guessable passwords
                    </div>
                    <div class="vulnerability-item">
                        <strong>Insufficient Session Expiration:</strong> Sessions that never expire or have very long timeouts
                    </div>
                    <div class="vulnerability-item">
                        <strong>Password Reset Vulnerabilities:</strong> Weak reset mechanisms that can be exploited
                    </div>
                    <div class="vulnerability-item">
                        <strong>JWT Vulnerabilities:</strong> Weak secrets, no expiration, algorithm confusion attacks
                    </div>
                </div>

                <h3>Security Testing Checklist</h3>
                <div class="practice-section">
                    <h4>üß™ Authentication Security Tests</h4>
                    <ul class="practice-list">
                        <li>Test for weak password policies and enforcement</li>
                        <li>Verify session management and timeout mechanisms</li>
                        <li>Test password reset functionality for vulnerabilities</li>
                        <li>Check for session fixation and hijacking vulnerabilities</li>
                        <li>Validate JWT implementation and security</li>
                        <li>Test OAuth 2.0 implementation for security flaws</li>
                        <li>Verify MFA implementation and bypass attempts</li>
                        <li>Test role-based access control mechanisms</li>
                        <li>Check for concurrent session handling</li>
                        <li>Validate account lockout and brute force protection</li>
                    </ul>
                </div>
            </div>

            <div class="quiz-section">
                <h3>üìù Knowledge Check</h3>

                <div class="quiz-question">
                    <h4>1. What is the primary difference between Authentication and Authorization?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">Authentication verifies identity, Authorization manages passwords</div>
                        <div class="quiz-option" data-correct="true">Authentication verifies identity, Authorization determines permissions</div>
                        <div class="quiz-option" data-correct="false">Authentication manages sessions, Authorization handles encryption</div>
                        <div class="quiz-option" data-correct="false">They are the same thing</div>
                    </div>
                    <div class="quiz-result" id="result1"></div>
                </div>

                <div class="quiz-question">
                    <h4>2. Which of the following is NOT a recommended practice for JWT security?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">Use strong, unique secrets</div>
                        <div class="quiz-option" data-correct="false">Implement token expiration</div>
                        <div class="quiz-option" data-correct="true">Store JWT payload data in localStorage</div>
                        <div class="quiz-option" data-correct="false">Use refresh tokens for long-term sessions</div>
                    </div>
                    <div class="quiz-result" id="result2"></div>
                </div>

                <div class="quiz-question">
                    <h4>3. What is the most secure OAuth 2.0 grant type for web applications?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">Implicit Grant</div>
                        <div class="quiz-option" data-correct="true">Authorization Code Grant</div>
                        <div class="quiz-option" data-correct="false">Resource Owner Password Credentials</div>
                        <div class="quiz-option" data-correct="false">Client Credentials</div>
                    </div>
                    <div class="quiz-result" id="result3"></div>
                </div>

                <div class="quiz-question">
                    <h4>4. Which access control model assigns permissions based on user roles?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">Attribute-Based Access Control (ABAC)</div>
                        <div class="quiz-option" data-correct="true">Role-Based Access Control (RBAC)</div>
                        <div class="quiz-option" data-correct="false">Mandatory Access Control (MAC)</div>
                        <div class="quiz-option" data-correct="false">Discretionary Access Control (DAC)</div>
                    </div>
                    <div class="quiz-result" id="result4"></div>
                </div>
            </div>

            <div class="navigation">
                <h3>üìö Chapter Navigation</h3>
                <p>Continue your cybersecurity learning journey:</p>

                <div class="nav-buttons">
                    <a href="cybersecurity1.html" class="nav-btn secondary">‚¨ÖÔ∏è Web Security Basics</a>
                    <a href="cybersecurity3.html" class="nav-btn">Data Protection & Encryption ‚û°Ô∏è</a>
                    <a href="study-guide-progress.html" class="nav-btn secondary">üìä Progress Dashboard</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Quiz functionality
        document.addEventListener('DOMContentLoaded', function() {
            const quizOptions = document.querySelectorAll('.quiz-option');

            quizOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const question = this.parentElement.parentElement;
                    const options = question.querySelectorAll('.quiz-option');
                    const resultDiv = question.querySelector('.quiz-result');
                    const questionNumber = question.querySelector('h4').textContent.split('.')[0];

                    // Remove previous selections
                    options.forEach(opt => {
                        opt.classList.remove('correct', 'incorrect');
                    });

                    // Check answer
                    const isCorrect = this.getAttribute('data-correct') === 'true';

                    if (isCorrect) {
                        this.classList.add('correct');
                        resultDiv.textContent = '‚úÖ Correct! Well done.';
                        resultDiv.className = 'quiz-result correct';
                    } else {
                        this.classList.add('incorrect');
                        resultDiv.textContent = '‚ùå Incorrect. Try again!';
                        resultDiv.className = 'quiz-result incorrect';
                    }

                    resultDiv.style.display = 'block';
                });
            });
        });
    </script>
</body>
</html>