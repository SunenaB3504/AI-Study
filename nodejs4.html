<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js Backend Development - Chapter 4: Authentication & Security</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#61dafb',
                        secondary: '#21a3c4',
                        accent: '#4caf50'
                    }
                }
            }
        }
    </script>
    <style>
        .status-completed { color: #22c55e; font-weight: bold; }
        .status-in-progress { color: #f59e0b; font-weight: bold; }
        .status-pending { color: #6b7280; font-weight: bold; }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e 0%, #f59e0b 60%, #6b7280 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <div class="bg-white rounded-xl shadow-2xl overflow-hidden">
            <!-- Header -->
            <div class="bg-gradient-to-r from-primary to-secondary text-white p-8 text-center">
                <h1 class="text-4xl font-bold mb-2">üîê Node.js Backend Development</h1>
                <div class="text-xl opacity-90 mb-4">Chapter 4: Authentication & Security</div>

                <!-- TTS Controls -->
                <div class="flex justify-center space-x-4 mb-4">
                    <button id="play-pause-btn" class="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors">
                        <span id="play-icon">‚ñ∂Ô∏è</span>
                        <span id="pause-icon" class="hidden">‚è∏Ô∏è</span>
                        Play
                    </button>
                    <button id="stop-btn" class="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors">
                        ‚èπÔ∏è Stop
                    </button>
                    <select id="voice-select" class="bg-white/20 text-white px-3 py-2 rounded-lg border-0">
                        <option value="">Default Voice</option>
                    </select>
                    <input type="range" id="rate-slider" min="0.5" max="2" step="0.1" value="1"
                           class="w-24 h-2 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    <span id="rate-value" class="text-sm">1x</span>
                </div>

                <!-- Chapter Progress -->
                <div class="max-w-2xl mx-auto">
                    <div class="flex justify-between text-sm mb-2">
                        <span>Chapter Progress</span>
                        <span id="chapter-progress">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill w-0"></div>
                    </div>
                </div>
            </div>

            <!-- Content -->
            <div class="p-8">
                <div class="bg-gray-50 p-6 rounded-lg mb-8 border-l-4 border-blue-500">
                    <h3 class="text-lg font-semibold text-blue-600 mb-4">üìö Chapter Navigation</h3>
                    <div class="flex flex-wrap gap-4">
                        <a href="study-guide-progress.html" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìä Progress Dashboard</a>
                        <a href="nodejs1.html" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìñ Chapter 1: Fundamentals</a>
                        <a href="nodejs2.html" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìñ Chapter 2: Express.js</a>
                        <a href="nodejs3.html" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìñ Chapter 3: Databases</a>
                        <a href="nodejs4.html" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìñ Current: Chapter 4</a>
                        <a href="nodejs5.html" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">üìñ Chapter 5: API Development</a>
                    </div>
                </div>

                <div class="mb-12">
                    <h2 class="text-2xl font-bold text-blue-600 border-b-2 border-gray-200 pb-3 mb-6">üîê Authentication vs Authorization</h2>
                    <p class="text-gray-700 mb-6">Understanding the fundamental concepts of authentication and authorization is crucial for building secure applications.</p>

                    <div class="overflow-x-auto bg-white rounded-lg shadow-md mb-6">
                        <table class="w-full">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-6 py-4 text-left font-semibold text-gray-700">Aspect</th>
                                    <th class="px-6 py-4 text-left font-semibold text-gray-700">Authentication</th>
                                    <th class="px-6 py-4 text-left font-semibold text-gray-700">Authorization</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
                                <tr class="hover:bg-gray-50">
                                    <td class="px-6 py-4 font-medium">Definition</td>
                                    <td class="px-6 py-4">Verifying who you are</td>
                                    <td class="px-6 py-4">Verifying what you can do</td>
                                </tr>
                                <tr class="hover:bg-gray-50 bg-gray-50">
                                    <td class="px-6 py-4 font-medium">Purpose</td>
                                    <td class="px-6 py-4">Identity verification</td>
                                    <td class="px-6 py-4">Access control</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-6 py-4 font-medium">Examples</td>
                                    <td class="px-6 py-4">Login, password verification</td>
                                    <td class="px-6 py-4">Role-based permissions, resource access</td>
                                </tr>
                                <tr class="hover:bg-gray-50 bg-gray-50">
                                    <td class="px-6 py-4 font-medium">Common Methods</td>
                                    <td class="px-6 py-4">JWT, sessions, OAuth</td>
                                    <td class="px-6 py-4">RBAC, ABAC, ACL</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-6 py-4 font-medium">Security Focus</td>
                                    <td class="px-6 py-4">Identity assurance</td>
                                    <td class="px-6 py-4">Access management</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="bg-red-50 border-l-4 border-red-500 p-6 rounded-r-lg mb-6">
                        <h4 class="text-red-700 font-semibold mb-3">üõ°Ô∏è Security First Approach</h4>
                        <ul class="text-red-700 space-y-1">
                            <li><strong>Defense in Depth:</strong> Multiple layers of security</li>
                            <li><strong>Fail-Safe Defaults:</strong> Secure by default, explicit permissions</li>
                            <li><strong>Principle of Least Privilege:</strong> Minimum required access</li>
                            <li><strong>Zero Trust:</strong> Never trust, always verify</li>
                            <li><strong>Security by Design:</strong> Security considerations from the start</li>
                        </ul>
                    </div>
                </div>

                <div class="mb-12">
                    <h2 class="text-2xl font-bold text-blue-600 border-b-2 border-gray-200 pb-3 mb-6">üîë Password Security</h2>
                    <p class="text-gray-700 mb-6">Proper password handling is fundamental to application security. Never store passwords in plain text.</p>

                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Password Hashing with bcrypt</h3>
                    <div class="bg-gray-100 border border-gray-200 rounded-lg p-6 mb-6 font-mono text-sm overflow-x-auto">
                        <div class="bg-gray-200 px-4 py-2 rounded-t-lg font-semibold text-gray-700 mb-3">Installing bcrypt and Setting Up Password Hashing</div>
                        <pre class="text-gray-800"># Install bcrypt
npm install bcrypt
npm install --save-dev @types/bcrypt  # For TypeScript

# Alternative: bcryptjs (pure JavaScript implementation)
npm install bcryptjs</pre>
                    </div>

                    <div class="bg-gray-100 border border-gray-200 rounded-lg p-6 mb-6 font-mono text-sm overflow-x-auto">
                        <div class="bg-gray-200 px-4 py-2 rounded-t-lg font-semibold text-gray-700 mb-3">Password Hashing and Verification</div>
                        <pre class="text-gray-800">const bcrypt = require('bcrypt');
const saltRounds = 12; // Recommended: 10-12 for production

class PasswordService {
    // Hash a password
    static async hashPassword(plainPassword) {
        try {
            // Generate salt and hash
            const salt = await bcrypt.genSalt(saltRounds);
            const hashedPassword = await bcrypt.hash(plainPassword, salt);

            return hashedPassword;
        } catch (error) {
            console.error('Error hashing password:', error);
            throw new Error('Password hashing failed');
        }
    }

    // Verify a password against its hash
    static async verifyPassword(plainPassword, hashedPassword) {
        try {
            const isValid = await bcrypt.compare(plainPassword, hashedPassword);
            return isValid;
        } catch (error) {
            console.error('Error verifying password:', error);
            return false;
        }
    }

    // Check password strength
    static validatePasswordStrength(password) {
        const errors = [];

        if (password.length < 8) {
            errors.push('Password must be at least 8 characters long');
        }

        if (!/[A-Z]/.test(password)) {
            errors.push('Password must contain at least one uppercase letter');
        }

        if (!/[a-z]/.test(password)) {
            errors.push('Password must contain at least one lowercase letter');
        }

        if (!/\d/.test(password)) {
            errors.push('Password must contain at least one number');
        }

        if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
            errors.push('Password must contain at least one special character');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }
}

module.exports = PasswordService;</pre>
                    </div>

                <h3>User Registration with Secure Password Handling</h3>
                <div class="code-block">
                    <div class="code-header">User Registration with Password Hashing</div>
const express = require('express');
const mongoose = require('mongoose');
const PasswordService = require('./services/PasswordService');

const app = express();
app.use(express.json());

// User Schema
const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
        trim: true,
        minlength: 3,
        maxlength: 50
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        validate: {
            validator: function(email) {
                return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email);
            },
            message: 'Please enter a valid email'
        }
    },
    password: {
        type: String,
        required: true,
        minlength: 8
    },
    role: {
        type: String,
        enum: ['user', 'admin', 'moderator'],
        default: 'user'
    },
    isActive: {
        type: Boolean,
        default: true
    },
    lastLogin: {
        type: Date
    },
    passwordChangedAt: {
        type: Date
    },
    loginAttempts: {
        type: Number,
        default: 0
    },
    lockUntil: {
        type: Date
    }
}, { timestamps: true });

// Pre-save middleware to hash password
userSchema.pre('save', async function(next) {
    // Only hash the password if it has been modified (or is new)
    if (!this.isModified('password')) return next();

    try {
        // Validate password strength
        const validation = PasswordService.validatePasswordStrength(this.password);
        if (!validation.isValid) {
            const error = new Error('Password does not meet requirements: ' + validation.errors.join(', '));
            return next(error);
        }

        // Hash password
        this.password = await PasswordService.hashPassword(this.password);
        this.passwordChangedAt = Date.now();
        next();
    } catch (error) {
        next(error);
    }
});

// Instance method to check password
userSchema.methods.comparePassword = async function(candidatePassword) {
    return await PasswordService.verifyPassword(candidatePassword, this.password);
};

// Instance method for account locking
userSchema.methods.incLoginAttempts = function() {
    // If we have a previous lock that has expired, restart at 1
    if (this.lockUntil && this.lockUntil < Date.now()) {
        return this.updateOne({
            $unset: { lockUntil: 1 },
            $set: { loginAttempts: 1 }
        });
    }

    const updates = { $inc: { loginAttempts: 1 } };

    // Lock account after 5 failed attempts for 2 hours
    if (this.loginAttempts + 1 >= 5 && !this.isLocked) {
        updates.$set = {
            lockUntil: Date.now() + 2 * 60 * 60 * 1000 // 2 hours
        };
    }

    return this.updateOne(updates);
};

// Virtual property to check if account is locked
userSchema.virtual('isLocked').get(function() {
    return !!(this.lockUntil && this.lockUntil > Date.now());
});

const User = mongoose.model('User', userSchema);

// Registration endpoint
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, password } = req.body;

        // Check if user already exists
        const existingUser = await User.findOne({
            $or: [{ email }, { username }]
        });

        if (existingUser) {
            return res.status(409).json({
                success: false,
                error: 'User with this email or username already exists'
            });
        }

        // Create new user
        const user = new User({
            username,
            email,
            password
        });

        await user.save();

        // Return user without password
        const userResponse = {
            _id: user._id,
            username: user.username,
            email: user.email,
            role: user.role,
            createdAt: user.createdAt
        };

        res.status(201).json({
            success: true,
            message: 'User registered successfully',
            data: userResponse
        });

    } catch (error) {
        console.error('Registration error:', error);

        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                error: error.message
            });
        }

        res.status(500).json({
            success: false,
            error: 'Registration failed'
        });
    }
});

module.exports = app;
                </div>
            </div>

                <div class="mb-12">
                    <h2 class="text-2xl font-bold text-blue-600 border-b-2 border-gray-200 pb-3 mb-6">üé´ JSON Web Tokens (JWT)</h2>
                    <p class="text-gray-700 mb-6">JWT is a compact, URL-safe means of representing claims to be transferred between two parties.</p>

                    <h3 class="text-xl font-semibold text-gray-800 mb-4">JWT Structure and Components</h3>
                    <div class="bg-gray-100 border border-gray-200 rounded-lg p-6 mb-6 font-mono text-sm overflow-x-auto">
                        <div class="bg-gray-200 px-4 py-2 rounded-t-lg font-semibold text-gray-700 mb-3">JWT Components</div>
                        <pre class="text-gray-800">// JWT Structure: header.payload.signature
// Example JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// Header: Algorithm and token type
const header = {
    "alg": "HS256",  // HMAC SHA256 algorithm
    "typ": "JWT"     // Token type
};

// Payload: Claims (user data)
const payload = {
    "sub": "1234567890",    // Subject (user ID)
    "name": "John Doe",     // User name
    "email": "john@example.com", // User email
    "role": "user",         // User role
    "iat": 1516239022,      // Issued at time
    "exp": 1516242622       // Expiration time
};

// Signature: Base64Url(header) + "." + Base64Url(payload) + secret</pre>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-800 mb-4">JWT Implementation</h3>
                    <div class="bg-gray-100 border border-gray-200 rounded-lg p-6 mb-6 font-mono text-sm overflow-x-auto">
                        <div class="bg-gray-200 px-4 py-2 rounded-t-lg font-semibold text-gray-700 mb-3">Installing and Setting Up JWT</div>
                        <pre class="text-gray-800"># Install jsonwebtoken
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken  # For TypeScript</pre>
                    </div>

                <div class="code-block">
                    <div class="code-header">JWT Service for Token Management</div>
const jwt = require('jsonwebtoken');

class JWTService {
    constructor() {
        this.secretKey = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';
        this.refreshSecretKey = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-key';
        this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '15m'; // 15 minutes
        this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d'; // 7 days
    }

    // Generate access token
    generateAccessToken(payload) {
        return jwt.sign(payload, this.secretKey, {
            expiresIn: this.accessTokenExpiry,
            issuer: 'your-app-name',
            audience: 'your-app-users'
        });
    }

    // Generate refresh token
    generateRefreshToken(payload) {
        return jwt.sign(payload, this.refreshSecretKey, {
            expiresIn: this.refreshTokenExpiry,
            issuer: 'your-app-name',
            audience: 'your-app-users'
        });
    }

    // Generate both tokens
    generateTokens(payload) {
        const accessToken = this.generateAccessToken(payload);
        const refreshToken = this.generateRefreshToken(payload);

        return {
            accessToken,
            refreshToken,
            accessTokenExpiry: this.accessTokenExpiry,
            refreshTokenExpiry: this.refreshTokenExpiry
        };
    }

    // Verify access token
    verifyAccessToken(token) {
        try {
            const decoded = jwt.verify(token, this.secretKey, {
                issuer: 'your-app-name',
                audience: 'your-app-users'
            });
            return { valid: true, decoded };
        } catch (error) {
            return {
                valid: false,
                error: error.message,
                expired: error.name === 'TokenExpiredError'
            };
        }
    }

    // Verify refresh token
    verifyRefreshToken(token) {
        try {
            const decoded = jwt.verify(token, this.refreshSecretKey, {
                issuer: 'your-app-name',
                audience: 'your-app-users'
            });
            return { valid: true, decoded };
        } catch (error) {
            return {
                valid: false,
                error: error.message,
                expired: error.name === 'TokenExpiredError'
            };
        }
    }

    // Extract token from Authorization header
    extractTokenFromHeader(authHeader) {
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return null;
        }
        return authHeader.substring(7); // Remove 'Bearer ' prefix
    }

    // Decode token without verification (for debugging)
    decodeToken(token) {
        try {
            return jwt.decode(token);
        } catch (error) {
            return null;
        }
    }
}

module.exports = JWTService;
                </div>

                <h3>JWT Authentication Middleware</h3>
                <div class="code-block">
                    <div class="code-header">JWT Authentication Middleware</div>
const JWTService = require('./services/JWTService');
const jwtService = new JWTService();

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = jwtService.extractTokenFromHeader(authHeader);

    if (!token) {
        return res.status(401).json({
            success: false,
            error: 'Access token required'
        });
    }

    const verification = jwtService.verifyAccessToken(token);

    if (!verification.valid) {
        if (verification.expired) {
            return res.status(401).json({
                success: false,
                error: 'Access token expired',
                code: 'TOKEN_EXPIRED'
            });
        }

        return res.status(403).json({
            success: false,
            error: 'Invalid access token'
        });
    }

    // Add user info to request object
    req.user = verification.decoded;
    next();
};

// Role-based authorization middleware
const authorizeRoles = (...roles) => {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({
                success: false,
                error: 'Authentication required'
            });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({
                success: false,
                error: 'Insufficient permissions'
            });
        }

        next();
    };
};

// Optional authentication (doesn't fail if no token)
const optionalAuth = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = jwtService.extractTokenFromHeader(authHeader);

    if (token) {
        const verification = jwtService.verifyAccessToken(token);
        if (verification.valid) {
            req.user = verification.decoded;
        }
    }

    next();
};

module.exports = {
    authenticateToken,
    authorizeRoles,
    optionalAuth
};
                </div>
            </div>

            <div class="section">
                <h2>üîÑ Login and Token Management</h2>
                <p>Complete authentication flow with login, logout, and token refresh functionality.</p>

                <h3>Login System</h3>
                <div class="code-block">
                    <div class="code-header">Complete Authentication System</div>
const express = require('express');
const mongoose = require('mongoose');
const PasswordService = require('./services/PasswordService');
const JWTService = require('./services/JWTService');
const { authenticateToken, authorizeRoles } = require('./middleware/auth');

const app = express();
app.use(express.json());

const jwtService = new JWTService();

// User model (assuming it's defined elsewhere)
const User = mongoose.model('User');

// Login endpoint
app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, username, password } = req.body;

        // Find user by email or username
        const user = await User.findOne({
            $or: [
                { email: email?.toLowerCase() },
                { username }
            ]
        });

        if (!user) {
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

        // Check if account is locked
        if (user.isLocked) {
            return res.status(423).json({
                success: false,
                error: 'Account is temporarily locked due to too many failed login attempts'
            });
        }

        // Verify password
        const isPasswordValid = await user.comparePassword(password);

        if (!isPasswordValid) {
            // Increment login attempts
            await user.incLoginAttempts();

            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

        // Reset login attempts on successful login
        if (user.loginAttempts > 0) {
            user.loginAttempts = 0;
            user.lockUntil = undefined;
            await user.save();
        }

        // Update last login
        user.lastLogin = new Date();
        await user.save();

        // Generate tokens
        const tokenPayload = {
            userId: user._id,
            username: user.username,
            email: user.email,
            role: user.role
        };

        const tokens = jwtService.generateTokens(tokenPayload);

        // Set refresh token as httpOnly cookie
        res.cookie('refreshToken', tokens.refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
        });

        res.json({
            success: true,
            message: 'Login successful',
            data: {
                user: {
                    _id: user._id,
                    username: user.username,
                    email: user.email,
                    role: user.role,
                    lastLogin: user.lastLogin
                },
                accessToken: tokens.accessToken,
                expiresIn: tokens.accessTokenExpiry
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({
            success: false,
            error: 'Login failed'
        });
    }
});

// Refresh token endpoint
app.post('/api/auth/refresh', async (req, res) => {
    try {
        const { refreshToken } = req.cookies;

        if (!refreshToken) {
            return res.status(401).json({
                success: false,
                error: 'Refresh token required'
            });
        }

        const verification = jwtService.verifyRefreshToken(refreshToken);

        if (!verification.valid) {
            return res.status(403).json({
                success: false,
                error: 'Invalid refresh token'
            });
        }

        // Find user to ensure they still exist and are active
        const user = await User.findById(verification.decoded.userId);

        if (!user || !user.isActive) {
            return res.status(403).json({
                success: false,
                error: 'User not found or inactive'
            });
        }

        // Generate new tokens
        const tokenPayload = {
            userId: user._id,
            username: user.username,
            email: user.email,
            role: user.role
        };

        const tokens = jwtService.generateTokens(tokenPayload);

        // Update refresh token cookie
        res.cookie('refreshToken', tokens.refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000
        });

        res.json({
            success: true,
            data: {
                accessToken: tokens.accessToken,
                expiresIn: tokens.accessTokenExpiry
            }
        });

    } catch (error) {
        console.error('Token refresh error:', error);
        res.status(500).json({
            success: false,
            error: 'Token refresh failed'
        });
    }
});

// Logout endpoint
app.post('/api/auth/logout', authenticateToken, async (req, res) => {
    try {
        // Clear refresh token cookie
        res.clearCookie('refreshToken');

        // Optional: Add token to blacklist in database
        // await TokenBlacklist.create({ token: req.token });

        res.json({
            success: true,
            message: 'Logout successful'
        });

    } catch (error) {
        console.error('Logout error:', error);
        res.status(500).json({
            success: false,
            error: 'Logout failed'
        });
    }
});

// Get current user profile
app.get('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const user = await User.findById(req.user.userId)
            .select('-password -loginAttempts -lockUntil');

        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }

        res.json({
            success: true,
            data: user
        });

    } catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch profile'
        });
    }
});

// Change password
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
    try {
        const { currentPassword, newPassword } = req.body;

        const user = await User.findById(req.user.userId);

        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }

        // Verify current password
        const isCurrentPasswordValid = await user.comparePassword(currentPassword);

        if (!isCurrentPasswordValid) {
            return res.status(400).json({
                success: false,
                error: 'Current password is incorrect'
            });
        }

        // Validate new password strength
        const validation = PasswordService.validatePasswordStrength(newPassword);
        if (!validation.isValid) {
            return res.status(400).json({
                success: false,
                error: 'New password does not meet requirements: ' + validation.errors.join(', ')
            });
        }

        // Update password
        user.password = newPassword;
        await user.save();

        res.json({
            success: true,
            message: 'Password changed successfully'
        });

    } catch (error) {
        console.error('Password change error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to change password'
        });
    }
});

// Protected routes examples
app.get('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req, res) => {
    // Only admins can access this
    const users = await User.find().select('-password');
    res.json({ success: true, data: users });
});

app.get('/api/user/posts', authenticateToken, async (req, res) => {
    // Any authenticated user can access this
    res.json({ success: true, message: 'User posts endpoint' });
});

module.exports = app;
                </div>
            </div>

            <div class="section">
                <h2>üõ°Ô∏è Security Best Practices</h2>
                <p>Essential security measures to protect your application and users.</p>

                <h3>Input Validation and Sanitization</h3>
                <div class="code-block">
                    <div class="code-header">Input Validation Middleware</div>
const validator = require('validator');
const rateLimit = require('express-rate-limit');

// Input validation middleware
const validateRegistration = (req, res, next) => {
    const { username, email, password } = req.body;
    const errors = [];

    // Username validation
    if (!username || typeof username !== 'string') {
        errors.push('Username is required');
    } else if (username.length < 3 || username.length > 50) {
        errors.push('Username must be between 3 and 50 characters');
    } else if (!/^[a-zA-Z0-9_]+$/.test(username)) {
        errors.push('Username can only contain letters, numbers, and underscores');
    }

    // Email validation
    if (!email || typeof email !== 'string') {
        errors.push('Email is required');
    } else if (!validator.isEmail(email)) {
        errors.push('Please provide a valid email address');
    }

    // Password validation (basic check, detailed check in PasswordService)
    if (!password || typeof password !== 'string') {
        errors.push('Password is required');
    } else if (password.length < 8) {
        errors.push('Password must be at least 8 characters long');
    }

    if (errors.length > 0) {
        return res.status(400).json({
            success: false,
            error: 'Validation failed',
            details: errors
        });
    }

    next();
};

// SQL injection prevention (when using raw SQL)
const sanitizeInput = (input) => {
    if (typeof input !== 'string') return input;
    return input.replace(/[<>'"&]/g, (char) => {
        const entityMap = {
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#x27;',
            '"': '&quot;',
            '&': '&amp;'
        };
        return entityMap[char];
    });
};

// XSS prevention middleware
const sanitizeBody = (req, res, next) => {
    const sanitizeObject = (obj) => {
        for (let key in obj) {
            if (typeof obj[key] === 'string') {
                obj[key] = sanitizeInput(obj[key]);
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                sanitizeObject(obj[key]);
            }
        }
    };

    if (req.body) {
        sanitizeObject(req.body);
    }

    next();
};

// Rate limiting
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit each IP to 5 requests per windowMs
    message: {
        success: false,
        error: 'Too many authentication attempts, please try again later'
    },
    standardHeaders: true,
    legacyHeaders: false,
});

const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: {
        success: false,
        error: 'Too many requests, please try again later'
    }
});

module.exports = {
    validateRegistration,
    sanitizeBody,
    authLimiter,
    apiLimiter
};
                </div>

                <h3>Security Headers and CORS</h3>
                <div class="code-block">
                    <div class="code-header">Security Middleware Setup</div>
const helmet = require('helmet');
const cors = require('cors');

// Security headers
const securityHeaders = helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
});

// CORS configuration
const corsOptions = {
    origin: function (origin, callback) {
        // Allow requests with no origin (mobile apps, etc.)
        if (!origin) return callback(null, true);

        const allowedOrigins = [
            'http://localhost:3000',
            'http://localhost:3001',
            'https://yourdomain.com',
            'https://www.yourdomain.com'
        ];

        if (allowedOrigins.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

// Apply security middleware
app.use(securityHeaders);
app.use(cors(corsOptions));

// Additional security headers
app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    next();
});
                </div>

                <h3>Environment Variables and Secrets</h3>
                <div class="code-block">
                    <div class="code-header">Environment Configuration</div>
# .env file (never commit to version control)
NODE_ENV=production
PORT=3000
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_REFRESH_SECRET=your-refresh-token-secret-key
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
MONGODB_URI=mongodb://localhost:27017/yourapp
REDIS_URL=redis://localhost:6379
EMAIL_SERVICE_API_KEY=your-email-service-api-key
STRIPE_SECRET_KEY=sk_test_your-stripe-secret-key
AWS_ACCESS_KEY_ID=your-aws-access-key
AWS_SECRET_ACCESS_KEY=your-aws-secret-key
                </div>

                <div class="code-block">
                    <div class="code-header">Environment Variables Validation</div>
require('dotenv').config();

class Config {
    static validate() {
        const required = [
            'JWT_SECRET',
            'DATABASE_URL'
        ];

        const missing = required.filter(key => !process.env[key]);

        if (missing.length > 0) {
            throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
        }

        // Validate JWT secret strength
        if (process.env.JWT_SECRET.length < 32) {
            console.warn('Warning: JWT_SECRET should be at least 32 characters long');
        }

        // Set defaults
        process.env.NODE_ENV = process.env.NODE_ENV || 'development';
        process.env.PORT = process.env.PORT || 3000;
    }

    static get isProduction() {
        return process.env.NODE_ENV === 'production';
    }

    static get isDevelopment() {
        return process.env.NODE_ENV === 'development';
    }

    static get port() {
        return parseInt(process.env.PORT, 10);
    }

    static get jwtSecret() {
        return process.env.JWT_SECRET;
    }

    static get databaseUrl() {
        return process.env.DATABASE_URL;
    }
}

// Validate configuration on startup
Config.validate();

module.exports = Config;
                </div>
            </div>

                <div class="bg-blue-50 border-l-4 border-blue-500 p-6 rounded-r-lg mb-8">
                    <h4 class="text-blue-700 font-semibold mb-4">üõ†Ô∏è Practice Exercise: Complete Authentication System</h4>
                    <p class="text-blue-700 mb-4">Build a complete authentication system with the following features:</p>
                    <ul class="text-blue-700 space-y-2 mb-4">
                        <li><strong>User Registration:</strong> Secure password hashing and validation</li>
                        <li><strong>User Login:</strong> JWT token generation and account locking</li>
                        <li><strong>Token Refresh:</strong> Automatic token renewal with refresh tokens</li>
                        <li><strong>Password Reset:</strong> Secure password reset flow with email</li>
                        <li><strong>Role-Based Access:</strong> Admin and user role permissions</li>
                        <li><strong>Security Features:</strong> Rate limiting, input validation, CORS</li>
                        <li><strong>Session Management:</strong> Proper logout and token blacklisting</li>
                    </ul>
                    <p class="text-blue-700 font-semibold mb-2">Requirements:</p>
                    <ul class="text-blue-700 space-y-1 mb-4">
                        <li>Use bcrypt for password hashing with salt rounds of 12</li>
                        <li>Implement JWT with separate access and refresh tokens</li>
                        <li>Add comprehensive input validation and sanitization</li>
                        <li>Implement rate limiting for authentication endpoints</li>
                        <li>Add proper error handling and logging</li>
                        <li>Use environment variables for all sensitive data</li>
                        <li>Implement account locking after failed login attempts</li>
                        <li>Add password strength requirements and validation</li>
                    </ul>
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-500 p-6 rounded-r-lg mb-8">
                    <h4 class="text-yellow-700 font-semibold mb-4">üìù Knowledge Check</h4>
                    <ol class="text-yellow-700 space-y-2">
                        <li>What is the difference between authentication and authorization?</li>
                        <li>Why should passwords never be stored in plain text?</li>
                        <li>Explain the structure of a JWT token and its three main components.</li>
                        <li>What is the purpose of refresh tokens in JWT authentication?</li>
                        <li>How does bcrypt work to secure passwords?</li>
                        <li>What are some common security vulnerabilities in web applications?</li>
                        <li>Why is rate limiting important for authentication endpoints?</li>
                        <li>How can you prevent SQL injection attacks in Node.js applications?</li>
                    </ol>
                </div>

                <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl p-8 mb-8">
                    <h3 class="text-2xl font-bold text-gray-800 mb-6">üìö Chapter Summary</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-blue-500">
                            <h5 class="text-blue-600 font-semibold mb-3">üîê Authentication System</h5>
                            <p class="text-gray-700">Complete user authentication with secure password hashing, JWT tokens, and session management for building secure web applications.</p>
                        </div>
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-green-500">
                            <h5 class="text-green-600 font-semibold mb-3">üõ°Ô∏è Security Best Practices</h5>
                            <p class="text-gray-700">Input validation, rate limiting, CORS configuration, and security headers to protect applications from common vulnerabilities.</p>
                        </div>
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-purple-500">
                            <h5 class="text-purple-600 font-semibold mb-3">üé´ JWT Implementation</h5>
                            <p class="text-gray-700">JSON Web Token implementation with access and refresh tokens, proper token verification, and secure token storage.</p>
                        </div>
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-red-500">
                            <h5 class="text-red-600 font-semibold mb-3">üîë Password Security</h5>
                            <p class="text-gray-700">Secure password handling with bcrypt hashing, password strength validation, and account protection mechanisms.</p>
                        </div>
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-orange-500">
                            <h5 class="text-orange-600 font-semibold mb-3">üö® Authorization & Access Control</h5>
                            <p class="text-gray-700">Role-based access control, middleware for route protection, and permission management for different user types.</p>
                        </div>
                        <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-teal-500">
                            <h5 class="text-teal-600 font-semibold mb-3">‚öôÔ∏è Production Security</h5>
                            <p class="text-gray-700">Environment variable management, configuration validation, and production-ready security configurations.</p>
                        </div>
                    </div>
                </div>

                <div class="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-orange-200 rounded-xl p-8 text-center mb-8">
                    <h3 class="text-2xl font-bold text-orange-700 mb-4">üéØ Ready for Chapter 5?</h3>
                    <p class="text-orange-700 mb-6">In the next chapter, we'll explore advanced API development covering RESTful APIs, GraphQL, API documentation, testing, and deployment strategies.</p>
                    <a href="nodejs5.html" class="bg-orange-500 hover:bg-orange-600 text-white px-8 py-3 rounded-lg font-semibold transition-colors inline-block">Continue to Chapter 5: API Development ‚Üí</a>
                </div>
            </div>
        </div>

        <!-- TTS and Chapter Tracking JavaScript -->
        <script>
            // Chapter tracking functionality
            class ChapterTracker {
                constructor() {
                    this.chapterId = 'nodejs4';
                    this.sections = document.querySelectorAll('.mb-12');
                    this.progressFill = document.getElementById('progress-fill');
                    this.progressText = document.getElementById('chapter-progress');
                    this.init();
                }

                init() {
                    this.loadProgress();
                    this.setupScrollTracking();
                    this.markChapterStarted();
                }

                loadProgress() {
                    const progress = localStorage.getItem(`chapter_${this.chapterId}_progress`) || 0;
                    this.updateProgress(progress);
                }

                setupScrollTracking() {
                    let ticking = false;
                    const updateProgress = () => {
                        const scrolled = window.scrollY;
                        const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
                        const progress = Math.min((scrolled / maxScroll) * 100, 100);

                        this.updateProgress(progress);
                        localStorage.setItem(`chapter_${this.chapterId}_progress`, progress);

                        ticking = false;
                    };

                    window.addEventListener('scroll', () => {
                        if (!ticking) {
                            requestAnimationFrame(updateProgress);
                            ticking = true;
                        }
                    });
                }

                updateProgress(progress) {
                    if (this.progressFill) {
                        this.progressFill.style.width = progress + '%';
                    }
                    if (this.progressText) {
                        this.progressText.textContent = Math.round(progress) + '%';
                    }
                }

                markChapterStarted() {
                    localStorage.setItem(`chapter_${this.chapterId}_started`, Date.now());
                }
            }

            // Text-to-Speech functionality
            class TextToSpeech {
                constructor() {
                    this.synth = window.speechSynthesis;
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.voiceSelect = document.getElementById('voice-select');
                    this.rateSlider = document.getElementById('rate-slider');
                    this.rateValue = document.getElementById('rate-value');
                    this.playPauseBtn = document.getElementById('play-pause-btn');
                    this.stopBtn = document.getElementById('stop-btn');
                    this.playIcon = document.getElementById('play-icon');
                    this.pauseIcon = document.getElementById('pause-icon');

                    this.init();
                }

                init() {
                    this.loadVoices();
                    this.setupEventListeners();
                    this.setupRateControl();

                    // Load saved preferences
                    const savedRate = localStorage.getItem('tts_rate') || 1;
                    this.rateSlider.value = savedRate;
                    this.updateRateValue(savedRate);
                }

                loadVoices() {
                    const voices = this.synth.getVoices();
                    if (voices.length > 0) {
                        this.populateVoiceSelect(voices);
                    } else {
                        // Some browsers load voices asynchronously
                        this.synth.onvoiceschanged = () => {
                            const voices = this.synth.getVoices();
                            this.populateVoiceSelect(voices);
                        };
                    }
                }

                populateVoiceSelect(voices) {
                    this.voiceSelect.innerHTML = '<option value="">Default Voice</option>';
                    voices.forEach((voice, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        this.voiceSelect.appendChild(option);
                    });
                }

                setupEventListeners() {
                    this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
                    this.stopBtn.addEventListener('click', () => this.stop());

                    this.voiceSelect.addEventListener('change', () => {
                        localStorage.setItem('tts_voice', this.voiceSelect.value);
                    });

                    // Load saved voice preference
                    const savedVoice = localStorage.getItem('tts_voice');
                    if (savedVoice) {
                        this.voiceSelect.value = savedVoice;
                    }
                }

                setupRateControl() {
                    this.rateSlider.addEventListener('input', (e) => {
                        const rate = e.target.value;
                        this.updateRateValue(rate);
                        localStorage.setItem('tts_rate', rate);

                        if (this.currentUtterance) {
                            this.currentUtterance.rate = rate;
                        }
                    });
                }

                updateRateValue(rate) {
                    this.rateValue.textContent = rate + 'x';
                }

                togglePlayPause() {
                    if (this.isPlaying) {
                        this.pause();
                    } else {
                        this.play();
                    }
                }

                play() {
                    if (this.synth.speaking) {
                        this.synth.resume();
                    } else {
                        this.speakContent();
                    }
                    this.isPlaying = true;
                    this.updatePlayButton();
                }

                pause() {
                    this.synth.pause();
                    this.isPlaying = false;
                    this.updatePlayButton();
                }

                stop() {
                    this.synth.cancel();
                    this.isPlaying = false;
                    this.currentUtterance = null;
                    this.updatePlayButton();
                }

                speakContent() {
                    const content = this.extractReadableContent();
                    const utterances = this.createUtterances(content);

                    utterances.forEach((utterance, index) => {
                        utterance.rate = parseFloat(this.rateSlider.value);

                        if (this.voiceSelect.value !== '') {
                            const voices = this.synth.getVoices();
                            const selectedVoice = voices[parseInt(this.voiceSelect.value)];
                            if (selectedVoice) {
                                utterance.voice = selectedVoice;
                            }
                        }

                        utterance.onend = () => {
                            if (index === utterances.length - 1) {
                                this.isPlaying = false;
                                this.updatePlayButton();
                            }
                        };

                        utterance.onerror = () => {
                            this.isPlaying = false;
                            this.updatePlayButton();
                        };

                        this.synth.speak(utterance);
                    });
                }

                extractReadableContent() {
                    const elements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li');
                    return Array.from(elements)
                        .map(el => el.textContent.trim())
                        .filter(text => text.length > 0)
                        .slice(0, 50); // Limit to first 50 elements
                }

                createUtterances(content) {
                    const utterances = [];
                    let currentUtterance = '';

                    content.forEach(text => {
                        if ((currentUtterance + text).length > 200) {
                            if (currentUtterance) {
                                utterances.push(new SpeechSynthesisUtterance(currentUtterance));
                            }
                            currentUtterance = text;
                        } else {
                            currentUtterance += (currentUtterance ? '. ' : '') + text;
                        }
                    });

                    if (currentUtterance) {
                        utterances.push(new SpeechSynthesisUtterance(currentUtterance));
                    }

                    return utterances;
                }

                updatePlayButton() {
                    if (this.isPlaying) {
                        this.playIcon.classList.add('hidden');
                        this.pauseIcon.classList.remove('hidden');
                        this.playPauseBtn.title = 'Pause';
                    } else {
                        this.playIcon.classList.remove('hidden');
                        this.pauseIcon.classList.add('hidden');
                        this.playPauseBtn.title = 'Play';
                    }
                }
            }

            // Initialize when DOM is loaded
            document.addEventListener('DOMContentLoaded', () => {
                new ChapterTracker();
                new TextToSpeech();
            });
        </script>
    </div>
</body>
</html>