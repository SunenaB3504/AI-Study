<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js Backend Development - Chapter 4: Authentication & Security</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }
        .content {
            padding: 40px;
        }
        .chapter-nav {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #4285f4;
        }
        .chapter-nav h3 {
            margin: 0 0 15px 0;
            color: #4285f4;
        }
        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .nav-btn {
            background: #4285f4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .nav-btn:hover {
            background: #3367d6;
        }
        .nav-btn.secondary {
            background: #34a853;
        }
        .nav-btn.secondary:hover {
            background: #2e7d32;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            color: #4285f4;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }
        .code-header {
            background: #e9ecef;
            padding: 10px 15px;
            margin: -20px -20px 15px -20px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            color: #495057;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .important {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        .important h4 {
            color: #721c24;
            margin: 0 0 10px 0;
        }
        .practice-exercise {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .practice-exercise h4 {
            color: #0c5460;
            margin: 0 0 15px 0;
        }
        .practice-exercise ul {
            margin: 0;
            padding-left: 20px;
        }
        .quiz {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .quiz h4 {
            color: #856404;
            margin: 0 0 15px 0;
        }
        .quiz ol {
            margin: 0;
            padding-left: 20px;
        }
        .quiz li {
            margin-bottom: 10px;
        }
        .summary {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }
        .summary h3 {
            color: #333;
            margin: 0 0 15px 0;
        }
        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .key-point {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4285f4;
        }
        .key-point h5 {
            color: #4285f4;
            margin: 0 0 10px 0;
        }
        .next-chapter {
            background: linear-gradient(135deg, #fff8e1 0%, #ffcc02 100%);
            border: 2px solid #ff9800;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }
        .next-chapter h3 {
            color: #e65100;
            margin: 0 0 15px 0;
        }
        .next-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 500;
            display: inline-block;
            transition: background-color 0.3s ease;
        }
        .next-btn:hover {
            background: #e65100;
        }
        .security-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .security-table th,
        .security-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        .security-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
        }
        .security-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        .security-table tr:hover {
            background: #e3f2fd;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Node.js Backend Development</h1>
            <div class="subtitle">Chapter 4: Authentication & Security</div>
        </div>

        <div class="content">
            <div class="chapter-nav">
                <h3>üìö Chapter Navigation</h3>
                <div class="nav-links">
                    <a href="study-guide-progress.html" class="nav-btn">üìä Progress Dashboard</a>
                    <a href="nodejs1.html" class="nav-btn">üìñ Chapter 1: Fundamentals</a>
                    <a href="nodejs2.html" class="nav-btn">üìñ Chapter 2: Express.js</a>
                    <a href="nodejs3.html" class="nav-btn">üìñ Chapter 3: Databases</a>
                    <a href="nodejs4.html" class="nav-btn secondary">üìñ Current: Chapter 4</a>
                    <a href="nodejs5.html" class="nav-btn">üìñ Chapter 5: API Development</a>
                </div>
            </div>

            <div class="section">
                <h2>üîê Authentication vs Authorization</h2>
                <p>Understanding the fundamental concepts of authentication and authorization is crucial for building secure applications.</p>

                <table class="security-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Authentication</th>
                            <th>Authorization</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Verifying who you are</td>
                            <td>Verifying what you can do</td>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Identity verification</td>
                            <td>Access control</td>
                        </tr>
                        <tr>
                            <td><strong>Examples</strong></td>
                            <td>Login, password verification</td>
                            <td>Role-based permissions, resource access</td>
                        </tr>
                        <tr>
                            <td><strong>Common Methods</strong></td>
                            <td>JWT, sessions, OAuth</td>
                            <td>RBAC, ABAC, ACL</td>
                        </tr>
                        <tr>
                            <td><strong>Security Focus</strong></td>
                            <td>Identity assurance</td>
                            <td>Access management</td>
                        </tr>
                    </tbody>
                </table>

                <div class="important">
                    <h4>üõ°Ô∏è Security First Approach</h4>
                    <ul>
                        <li><strong>Defense in Depth:</strong> Multiple layers of security</li>
                        <li><strong>Fail-Safe Defaults:</strong> Secure by default, explicit permissions</li>
                        <li><strong>Principle of Least Privilege:</strong> Minimum required access</li>
                        <li><strong>Zero Trust:</strong> Never trust, always verify</li>
                        <li><strong>Security by Design:</strong> Security considerations from the start</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>üîë Password Security</h2>
                <p>Proper password handling is fundamental to application security. Never store passwords in plain text.</p>

                <h3>Password Hashing with bcrypt</h3>
                <div class="code-block">
                    <div class="code-header">Installing bcrypt and Setting Up Password Hashing</div>
# Install bcrypt
npm install bcrypt
npm install --save-dev @types/bcrypt  # For TypeScript

# Alternative: bcryptjs (pure JavaScript implementation)
npm install bcryptjs
                </div>

                <div class="code-block">
                    <div class="code-header">Password Hashing and Verification</div>
const bcrypt = require('bcrypt');
const saltRounds = 12; // Recommended: 10-12 for production

class PasswordService {
    // Hash a password
    static async hashPassword(plainPassword) {
        try {
            // Generate salt and hash
            const salt = await bcrypt.genSalt(saltRounds);
            const hashedPassword = await bcrypt.hash(plainPassword, salt);

            return hashedPassword;
        } catch (error) {
            console.error('Error hashing password:', error);
            throw new Error('Password hashing failed');
        }
    }

    // Verify a password against its hash
    static async verifyPassword(plainPassword, hashedPassword) {
        try {
            const isValid = await bcrypt.compare(plainPassword, hashedPassword);
            return isValid;
        } catch (error) {
            console.error('Error verifying password:', error);
            return false;
        }
    }

    // Check password strength
    static validatePasswordStrength(password) {
        const errors = [];

        if (password.length < 8) {
            errors.push('Password must be at least 8 characters long');
        }

        if (!/[A-Z]/.test(password)) {
            errors.push('Password must contain at least one uppercase letter');
        }

        if (!/[a-z]/.test(password)) {
            errors.push('Password must contain at least one lowercase letter');
        }

        if (!/\d/.test(password)) {
            errors.push('Password must contain at least one number');
        }

        if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
            errors.push('Password must contain at least one special character');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }
}

module.exports = PasswordService;
                </div>

                <h3>User Registration with Secure Password Handling</h3>
                <div class="code-block">
                    <div class="code-header">User Registration with Password Hashing</div>
const express = require('express');
const mongoose = require('mongoose');
const PasswordService = require('./services/PasswordService');

const app = express();
app.use(express.json());

// User Schema
const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
        trim: true,
        minlength: 3,
        maxlength: 50
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        validate: {
            validator: function(email) {
                return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(email);
            },
            message: 'Please enter a valid email'
        }
    },
    password: {
        type: String,
        required: true,
        minlength: 8
    },
    role: {
        type: String,
        enum: ['user', 'admin', 'moderator'],
        default: 'user'
    },
    isActive: {
        type: Boolean,
        default: true
    },
    lastLogin: {
        type: Date
    },
    passwordChangedAt: {
        type: Date
    },
    loginAttempts: {
        type: Number,
        default: 0
    },
    lockUntil: {
        type: Date
    }
}, { timestamps: true });

// Pre-save middleware to hash password
userSchema.pre('save', async function(next) {
    // Only hash the password if it has been modified (or is new)
    if (!this.isModified('password')) return next();

    try {
        // Validate password strength
        const validation = PasswordService.validatePasswordStrength(this.password);
        if (!validation.isValid) {
            const error = new Error('Password does not meet requirements: ' + validation.errors.join(', '));
            return next(error);
        }

        // Hash password
        this.password = await PasswordService.hashPassword(this.password);
        this.passwordChangedAt = Date.now();
        next();
    } catch (error) {
        next(error);
    }
});

// Instance method to check password
userSchema.methods.comparePassword = async function(candidatePassword) {
    return await PasswordService.verifyPassword(candidatePassword, this.password);
};

// Instance method for account locking
userSchema.methods.incLoginAttempts = function() {
    // If we have a previous lock that has expired, restart at 1
    if (this.lockUntil && this.lockUntil < Date.now()) {
        return this.updateOne({
            $unset: { lockUntil: 1 },
            $set: { loginAttempts: 1 }
        });
    }

    const updates = { $inc: { loginAttempts: 1 } };

    // Lock account after 5 failed attempts for 2 hours
    if (this.loginAttempts + 1 >= 5 && !this.isLocked) {
        updates.$set = {
            lockUntil: Date.now() + 2 * 60 * 60 * 1000 // 2 hours
        };
    }

    return this.updateOne(updates);
};

// Virtual property to check if account is locked
userSchema.virtual('isLocked').get(function() {
    return !!(this.lockUntil && this.lockUntil > Date.now());
});

const User = mongoose.model('User', userSchema);

// Registration endpoint
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, password } = req.body;

        // Check if user already exists
        const existingUser = await User.findOne({
            $or: [{ email }, { username }]
        });

        if (existingUser) {
            return res.status(409).json({
                success: false,
                error: 'User with this email or username already exists'
            });
        }

        // Create new user
        const user = new User({
            username,
            email,
            password
        });

        await user.save();

        // Return user without password
        const userResponse = {
            _id: user._id,
            username: user.username,
            email: user.email,
            role: user.role,
            createdAt: user.createdAt
        };

        res.status(201).json({
            success: true,
            message: 'User registered successfully',
            data: userResponse
        });

    } catch (error) {
        console.error('Registration error:', error);

        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                error: error.message
            });
        }

        res.status(500).json({
            success: false,
            error: 'Registration failed'
        });
    }
});

module.exports = app;
                </div>
            </div>

            <div class="section">
                <h2>üé´ JSON Web Tokens (JWT)</h2>
                <p>JWT is a compact, URL-safe means of representing claims to be transferred between two parties.</p>

                <h3>JWT Structure and Components</h3>
                <div class="code-block">
                    <div class="code-header">JWT Components</div>
// JWT Structure: header.payload.signature
// Example JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// Header: Algorithm and token type
const header = {
    "alg": "HS256",  // HMAC SHA256 algorithm
    "typ": "JWT"     // Token type
};

// Payload: Claims (user data)
const payload = {
    "sub": "1234567890",    // Subject (user ID)
    "name": "John Doe",     // User name
    "email": "john@example.com", // User email
    "role": "user",         // User role
    "iat": 1516239022,      // Issued at time
    "exp": 1516242622       // Expiration time
};

// Signature: Base64Url(header) + "." + Base64Url(payload) + secret
                </div>

                <h3>JWT Implementation</h3>
                <div class="code-block">
                    <div class="code-header">Installing and Setting Up JWT</div>
# Install jsonwebtoken
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken  # For TypeScript
                </div>

                <div class="code-block">
                    <div class="code-header">JWT Service for Token Management</div>
const jwt = require('jsonwebtoken');

class JWTService {
    constructor() {
        this.secretKey = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';
        this.refreshSecretKey = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-key';
        this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '15m'; // 15 minutes
        this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d'; // 7 days
    }

    // Generate access token
    generateAccessToken(payload) {
        return jwt.sign(payload, this.secretKey, {
            expiresIn: this.accessTokenExpiry,
            issuer: 'your-app-name',
            audience: 'your-app-users'
        });
    }

    // Generate refresh token
    generateRefreshToken(payload) {
        return jwt.sign(payload, this.refreshSecretKey, {
            expiresIn: this.refreshTokenExpiry,
            issuer: 'your-app-name',
            audience: 'your-app-users'
        });
    }

    // Generate both tokens
    generateTokens(payload) {
        const accessToken = this.generateAccessToken(payload);
        const refreshToken = this.generateRefreshToken(payload);

        return {
            accessToken,
            refreshToken,
            accessTokenExpiry: this.accessTokenExpiry,
            refreshTokenExpiry: this.refreshTokenExpiry
        };
    }

    // Verify access token
    verifyAccessToken(token) {
        try {
            const decoded = jwt.verify(token, this.secretKey, {
                issuer: 'your-app-name',
                audience: 'your-app-users'
            });
            return { valid: true, decoded };
        } catch (error) {
            return {
                valid: false,
                error: error.message,
                expired: error.name === 'TokenExpiredError'
            };
        }
    }

    // Verify refresh token
    verifyRefreshToken(token) {
        try {
            const decoded = jwt.verify(token, this.refreshSecretKey, {
                issuer: 'your-app-name',
                audience: 'your-app-users'
            });
            return { valid: true, decoded };
        } catch (error) {
            return {
                valid: false,
                error: error.message,
                expired: error.name === 'TokenExpiredError'
            };
        }
    }

    // Extract token from Authorization header
    extractTokenFromHeader(authHeader) {
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return null;
        }
        return authHeader.substring(7); // Remove 'Bearer ' prefix
    }

    // Decode token without verification (for debugging)
    decodeToken(token) {
        try {
            return jwt.decode(token);
        } catch (error) {
            return null;
        }
    }
}

module.exports = JWTService;
                </div>

                <h3>JWT Authentication Middleware</h3>
                <div class="code-block">
                    <div class="code-header">JWT Authentication Middleware</div>
const JWTService = require('./services/JWTService');
const jwtService = new JWTService();

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = jwtService.extractTokenFromHeader(authHeader);

    if (!token) {
        return res.status(401).json({
            success: false,
            error: 'Access token required'
        });
    }

    const verification = jwtService.verifyAccessToken(token);

    if (!verification.valid) {
        if (verification.expired) {
            return res.status(401).json({
                success: false,
                error: 'Access token expired',
                code: 'TOKEN_EXPIRED'
            });
        }

        return res.status(403).json({
            success: false,
            error: 'Invalid access token'
        });
    }

    // Add user info to request object
    req.user = verification.decoded;
    next();
};

// Role-based authorization middleware
const authorizeRoles = (...roles) => {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({
                success: false,
                error: 'Authentication required'
            });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({
                success: false,
                error: 'Insufficient permissions'
            });
        }

        next();
    };
};

// Optional authentication (doesn't fail if no token)
const optionalAuth = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = jwtService.extractTokenFromHeader(authHeader);

    if (token) {
        const verification = jwtService.verifyAccessToken(token);
        if (verification.valid) {
            req.user = verification.decoded;
        }
    }

    next();
};

module.exports = {
    authenticateToken,
    authorizeRoles,
    optionalAuth
};
                </div>
            </div>

            <div class="section">
                <h2>üîÑ Login and Token Management</h2>
                <p>Complete authentication flow with login, logout, and token refresh functionality.</p>

                <h3>Login System</h3>
                <div class="code-block">
                    <div class="code-header">Complete Authentication System</div>
const express = require('express');
const mongoose = require('mongoose');
const PasswordService = require('./services/PasswordService');
const JWTService = require('./services/JWTService');
const { authenticateToken, authorizeRoles } = require('./middleware/auth');

const app = express();
app.use(express.json());

const jwtService = new JWTService();

// User model (assuming it's defined elsewhere)
const User = mongoose.model('User');

// Login endpoint
app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, username, password } = req.body;

        // Find user by email or username
        const user = await User.findOne({
            $or: [
                { email: email?.toLowerCase() },
                { username }
            ]
        });

        if (!user) {
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

        // Check if account is locked
        if (user.isLocked) {
            return res.status(423).json({
                success: false,
                error: 'Account is temporarily locked due to too many failed login attempts'
            });
        }

        // Verify password
        const isPasswordValid = await user.comparePassword(password);

        if (!isPasswordValid) {
            // Increment login attempts
            await user.incLoginAttempts();

            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

        // Reset login attempts on successful login
        if (user.loginAttempts > 0) {
            user.loginAttempts = 0;
            user.lockUntil = undefined;
            await user.save();
        }

        // Update last login
        user.lastLogin = new Date();
        await user.save();

        // Generate tokens
        const tokenPayload = {
            userId: user._id,
            username: user.username,
            email: user.email,
            role: user.role
        };

        const tokens = jwtService.generateTokens(tokenPayload);

        // Set refresh token as httpOnly cookie
        res.cookie('refreshToken', tokens.refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
        });

        res.json({
            success: true,
            message: 'Login successful',
            data: {
                user: {
                    _id: user._id,
                    username: user.username,
                    email: user.email,
                    role: user.role,
                    lastLogin: user.lastLogin
                },
                accessToken: tokens.accessToken,
                expiresIn: tokens.accessTokenExpiry
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({
            success: false,
            error: 'Login failed'
        });
    }
});

// Refresh token endpoint
app.post('/api/auth/refresh', async (req, res) => {
    try {
        const { refreshToken } = req.cookies;

        if (!refreshToken) {
            return res.status(401).json({
                success: false,
                error: 'Refresh token required'
            });
        }

        const verification = jwtService.verifyRefreshToken(refreshToken);

        if (!verification.valid) {
            return res.status(403).json({
                success: false,
                error: 'Invalid refresh token'
            });
        }

        // Find user to ensure they still exist and are active
        const user = await User.findById(verification.decoded.userId);

        if (!user || !user.isActive) {
            return res.status(403).json({
                success: false,
                error: 'User not found or inactive'
            });
        }

        // Generate new tokens
        const tokenPayload = {
            userId: user._id,
            username: user.username,
            email: user.email,
            role: user.role
        };

        const tokens = jwtService.generateTokens(tokenPayload);

        // Update refresh token cookie
        res.cookie('refreshToken', tokens.refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000
        });

        res.json({
            success: true,
            data: {
                accessToken: tokens.accessToken,
                expiresIn: tokens.accessTokenExpiry
            }
        });

    } catch (error) {
        console.error('Token refresh error:', error);
        res.status(500).json({
            success: false,
            error: 'Token refresh failed'
        });
    }
});

// Logout endpoint
app.post('/api/auth/logout', authenticateToken, async (req, res) => {
    try {
        // Clear refresh token cookie
        res.clearCookie('refreshToken');

        // Optional: Add token to blacklist in database
        // await TokenBlacklist.create({ token: req.token });

        res.json({
            success: true,
            message: 'Logout successful'
        });

    } catch (error) {
        console.error('Logout error:', error);
        res.status(500).json({
            success: false,
            error: 'Logout failed'
        });
    }
});

// Get current user profile
app.get('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const user = await User.findById(req.user.userId)
            .select('-password -loginAttempts -lockUntil');

        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }

        res.json({
            success: true,
            data: user
        });

    } catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch profile'
        });
    }
});

// Change password
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
    try {
        const { currentPassword, newPassword } = req.body;

        const user = await User.findById(req.user.userId);

        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }

        // Verify current password
        const isCurrentPasswordValid = await user.comparePassword(currentPassword);

        if (!isCurrentPasswordValid) {
            return res.status(400).json({
                success: false,
                error: 'Current password is incorrect'
            });
        }

        // Validate new password strength
        const validation = PasswordService.validatePasswordStrength(newPassword);
        if (!validation.isValid) {
            return res.status(400).json({
                success: false,
                error: 'New password does not meet requirements: ' + validation.errors.join(', ')
            });
        }

        // Update password
        user.password = newPassword;
        await user.save();

        res.json({
            success: true,
            message: 'Password changed successfully'
        });

    } catch (error) {
        console.error('Password change error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to change password'
        });
    }
});

// Protected routes examples
app.get('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req, res) => {
    // Only admins can access this
    const users = await User.find().select('-password');
    res.json({ success: true, data: users });
});

app.get('/api/user/posts', authenticateToken, async (req, res) => {
    // Any authenticated user can access this
    res.json({ success: true, message: 'User posts endpoint' });
});

module.exports = app;
                </div>
            </div>

            <div class="section">
                <h2>üõ°Ô∏è Security Best Practices</h2>
                <p>Essential security measures to protect your application and users.</p>

                <h3>Input Validation and Sanitization</h3>
                <div class="code-block">
                    <div class="code-header">Input Validation Middleware</div>
const validator = require('validator');
const rateLimit = require('express-rate-limit');

// Input validation middleware
const validateRegistration = (req, res, next) => {
    const { username, email, password } = req.body;
    const errors = [];

    // Username validation
    if (!username || typeof username !== 'string') {
        errors.push('Username is required');
    } else if (username.length < 3 || username.length > 50) {
        errors.push('Username must be between 3 and 50 characters');
    } else if (!/^[a-zA-Z0-9_]+$/.test(username)) {
        errors.push('Username can only contain letters, numbers, and underscores');
    }

    // Email validation
    if (!email || typeof email !== 'string') {
        errors.push('Email is required');
    } else if (!validator.isEmail(email)) {
        errors.push('Please provide a valid email address');
    }

    // Password validation (basic check, detailed check in PasswordService)
    if (!password || typeof password !== 'string') {
        errors.push('Password is required');
    } else if (password.length < 8) {
        errors.push('Password must be at least 8 characters long');
    }

    if (errors.length > 0) {
        return res.status(400).json({
            success: false,
            error: 'Validation failed',
            details: errors
        });
    }

    next();
};

// SQL injection prevention (when using raw SQL)
const sanitizeInput = (input) => {
    if (typeof input !== 'string') return input;
    return input.replace(/[<>'"&]/g, (char) => {
        const entityMap = {
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#x27;',
            '"': '&quot;',
            '&': '&amp;'
        };
        return entityMap[char];
    });
};

// XSS prevention middleware
const sanitizeBody = (req, res, next) => {
    const sanitizeObject = (obj) => {
        for (let key in obj) {
            if (typeof obj[key] === 'string') {
                obj[key] = sanitizeInput(obj[key]);
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                sanitizeObject(obj[key]);
            }
        }
    };

    if (req.body) {
        sanitizeObject(req.body);
    }

    next();
};

// Rate limiting
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit each IP to 5 requests per windowMs
    message: {
        success: false,
        error: 'Too many authentication attempts, please try again later'
    },
    standardHeaders: true,
    legacyHeaders: false,
});

const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: {
        success: false,
        error: 'Too many requests, please try again later'
    }
});

module.exports = {
    validateRegistration,
    sanitizeBody,
    authLimiter,
    apiLimiter
};
                </div>

                <h3>Security Headers and CORS</h3>
                <div class="code-block">
                    <div class="code-header">Security Middleware Setup</div>
const helmet = require('helmet');
const cors = require('cors');

// Security headers
const securityHeaders = helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
});

// CORS configuration
const corsOptions = {
    origin: function (origin, callback) {
        // Allow requests with no origin (mobile apps, etc.)
        if (!origin) return callback(null, true);

        const allowedOrigins = [
            'http://localhost:3000',
            'http://localhost:3001',
            'https://yourdomain.com',
            'https://www.yourdomain.com'
        ];

        if (allowedOrigins.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

// Apply security middleware
app.use(securityHeaders);
app.use(cors(corsOptions));

// Additional security headers
app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    next();
});
                </div>

                <h3>Environment Variables and Secrets</h3>
                <div class="code-block">
                    <div class="code-header">Environment Configuration</div>
# .env file (never commit to version control)
NODE_ENV=production
PORT=3000
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_REFRESH_SECRET=your-refresh-token-secret-key
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
MONGODB_URI=mongodb://localhost:27017/yourapp
REDIS_URL=redis://localhost:6379
EMAIL_SERVICE_API_KEY=your-email-service-api-key
STRIPE_SECRET_KEY=sk_test_your-stripe-secret-key
AWS_ACCESS_KEY_ID=your-aws-access-key
AWS_SECRET_ACCESS_KEY=your-aws-secret-key
                </div>

                <div class="code-block">
                    <div class="code-header">Environment Variables Validation</div>
require('dotenv').config();

class Config {
    static validate() {
        const required = [
            'JWT_SECRET',
            'DATABASE_URL'
        ];

        const missing = required.filter(key => !process.env[key]);

        if (missing.length > 0) {
            throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
        }

        // Validate JWT secret strength
        if (process.env.JWT_SECRET.length < 32) {
            console.warn('Warning: JWT_SECRET should be at least 32 characters long');
        }

        // Set defaults
        process.env.NODE_ENV = process.env.NODE_ENV || 'development';
        process.env.PORT = process.env.PORT || 3000;
    }

    static get isProduction() {
        return process.env.NODE_ENV === 'production';
    }

    static get isDevelopment() {
        return process.env.NODE_ENV === 'development';
    }

    static get port() {
        return parseInt(process.env.PORT, 10);
    }

    static get jwtSecret() {
        return process.env.JWT_SECRET;
    }

    static get databaseUrl() {
        return process.env.DATABASE_URL;
    }
}

// Validate configuration on startup
Config.validate();

module.exports = Config;
                </div>
            </div>

            <div class="practice-exercise">
                <h4>üõ†Ô∏è Practice Exercise: Complete Authentication System</h4>
                <p>Build a complete authentication system with the following features:</p>
                <ul>
                    <li><strong>User Registration:</strong> Secure password hashing and validation</li>
                    <li><strong>User Login:</strong> JWT token generation and account locking</li>
                    <li><strong>Token Refresh:</strong> Automatic token renewal with refresh tokens</li>
                    <li><strong>Password Reset:</strong> Secure password reset flow with email</li>
                    <li><strong>Role-Based Access:</strong> Admin and user role permissions</li>
                    <li><strong>Security Features:</strong> Rate limiting, input validation, CORS</li>
                    <li><strong>Session Management:</strong> Proper logout and token blacklisting</li>
                </ul>
                <p><strong>Requirements:</strong></p>
                <ul>
                    <li>Use bcrypt for password hashing with salt rounds of 12</li>
                    <li>Implement JWT with separate access and refresh tokens</li>
                    <li>Add comprehensive input validation and sanitization</li>
                    <li>Implement rate limiting for authentication endpoints</li>
                    <li>Add proper error handling and logging</li>
                    <li>Use environment variables for all sensitive data</li>
                    <li>Implement account locking after failed login attempts</li>
                    <li>Add password strength requirements and validation</li>
                </ul>
            </div>

            <div class="quiz">
                <h4>üìù Knowledge Check</h4>
                <ol>
                    <li>What is the difference between authentication and authorization?</li>
                    <li>Why should passwords never be stored in plain text?</li>
                    <li>Explain the structure of a JWT token and its three main components.</li>
                    <li>What is the purpose of refresh tokens in JWT authentication?</li>
                    <li>How does bcrypt work to secure passwords?</li>
                    <li>What are some common security vulnerabilities in web applications?</li>
                    <li>Why is rate limiting important for authentication endpoints?</li>
                    <li>How can you prevent SQL injection attacks in Node.js applications?</li>
                </ol>
            </div>

            <div class="summary">
                <h3>üìö Chapter Summary</h3>
                <div class="key-points">
                    <div class="key-point">
                        <h5>üîê Authentication System</h5>
                        <p>Complete user authentication with secure password hashing, JWT tokens, and session management for building secure web applications.</p>
                    </div>
                    <div class="key-point">
                        <h5>üõ°Ô∏è Security Best Practices</h5>
                        <p>Input validation, rate limiting, CORS configuration, and security headers to protect applications from common vulnerabilities.</p>
                    </div>
                    <div class="key-point">
                        <h5>üé´ JWT Implementation</h5>
                        <p>JSON Web Token implementation with access and refresh tokens, proper token verification, and secure token storage.</p>
                    </div>
                    <div class="key-point">
                        <h5>üîë Password Security</h5>
                        <p>Secure password handling with bcrypt hashing, password strength validation, and account protection mechanisms.</p>
                    </div>
                    <div class="key-point">
                        <h5>üö® Authorization & Access Control</h5>
                        <p>Role-based access control, middleware for route protection, and permission management for different user types.</p>
                    </div>
                    <div class="key-point">
                        <h5>‚öôÔ∏è Production Security</h5>
                        <p>Environment variable management, configuration validation, and production-ready security configurations.</p>
                    </div>
                </div>
            </div>

            <div class="next-chapter">
                <h3>üéØ Ready for Chapter 5?</h3>
                <p>In the next chapter, we'll explore advanced API development covering RESTful APIs, GraphQL, API documentation, testing, and deployment strategies.</p>
                <a href="nodejs5.html" class="next-btn">Continue to Chapter 5: API Development ‚Üí</a>
            </div>
        </div>
    </div>
</body>
</html>