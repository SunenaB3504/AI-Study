<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js Backend Development - Chapter 5: API Development</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }
        .content {
            padding: 40px;
        }
        .chapter-nav {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #4285f4;
        }
        .chapter-nav h3 {
            margin: 0 0 15px 0;
            color: #4285f4;
        }
        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .nav-btn {
            background: #4285f4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .nav-btn:hover {
            background: #3367d6;
        }
        .nav-btn.secondary {
            background: #34a853;
        }
        .nav-btn.secondary:hover {
            background: #2e7d32;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            color: #4285f4;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }
        .code-header {
            background: #e9ecef;
            padding: 10px 15px;
            margin: -20px -20px 15px -20px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            color: #495057;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .important {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        .important h4 {
            color: #721c24;
            margin: 0 0 10px 0;
        }
        .practice-exercise {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .practice-exercise h4 {
            color: #0c5460;
            margin: 0 0 15px 0;
        }
        .practice-exercise ul {
            margin: 0;
            padding-left: 20px;
        }
        .quiz {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .quiz h4 {
            color: #856404;
            margin: 0 0 15px 0;
        }
        .quiz ol {
            margin: 0;
            padding-left: 20px;
        }
        .quiz li {
            margin-bottom: 10px;
        }
        .summary {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }
        .summary h3 {
            color: #333;
            margin: 0 0 15px 0;
        }
        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .key-point {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4285f4;
        }
        .key-point h5 {
            color: #4285f4;
            margin: 0 0 10px 0;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        .comparison-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
        }
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        .comparison-table tr:hover {
            background: #e3f2fd;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Node.js Backend Development</h1>
            <div class="subtitle">Chapter 5: API Development</div>
        </div>

        <div class="content">
            <div class="chapter-nav">
                <h3>üìö Chapter Navigation</h3>
                <div class="nav-links">
                    <a href="study-guide-progress.html" class="nav-btn">üìä Progress Dashboard</a>
                    <a href="nodejs1.html" class="nav-btn">üìñ Chapter 1: Fundamentals</a>
                    <a href="nodejs2.html" class="nav-btn">üìñ Chapter 2: Express.js</a>
                    <a href="nodejs3.html" class="nav-btn">üìñ Chapter 3: Databases</a>
                    <a href="nodejs4.html" class="nav-btn">üìñ Chapter 4: Auth & Security</a>
                    <a href="nodejs5.html" class="nav-btn secondary">üìñ Current: Chapter 5</a>
                </div>
            </div>

            <div class="section">
                <h2>üåê RESTful API Design Principles</h2>
                <p>REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs follow specific conventions and principles.</p>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Principle</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Resource-Based</strong></td>
                            <td>Everything is a resource with unique URI</td>
                            <td><code>/api/users/123</code></td>
                        </tr>
                        <tr>
                            <td><strong>HTTP Methods</strong></td>
                            <td>Use HTTP methods for operations</td>
                            <td>GET, POST, PUT, DELETE</td>
                        </tr>
                        <tr>
                            <td><strong>Stateless</strong></td>
                            <td>Each request contains all needed info</td>
                            <td>JWT tokens, API keys</td>
                        </tr>
                        <tr>
                            <td><strong>Uniform Interface</strong></td>
                            <td>Consistent resource identification</td>
                            <td>Standard HTTP status codes</td>
                        </tr>
                        <tr>
                            <td><strong>HATEOAS</strong></td>
                            <td>Hypermedia as engine of state</td>
                            <td>Links in API responses</td>
                        </tr>
                    </tbody>
                </table>

                <h3>RESTful Resource Naming</h3>
                <div class="code-block">
                    <div class="code-header">RESTful API Endpoint Examples</div>
// Good RESTful endpoints
GET    /api/users           # Get all users
GET    /api/users/123       # Get user with ID 123
POST   /api/users           # Create new user
PUT    /api/users/123       # Update user 123
DELETE /api/users/123       # Delete user 123

GET    /api/users/123/posts # Get posts by user 123
POST   /api/users/123/posts # Create post for user 123

GET    /api/posts?author=123&status=published # Query with filters
GET    /api/posts?page=2&limit=10 # Pagination

// Avoid these patterns
GET    /api/getUsers        # Don't use verbs in endpoints
POST   /api/users/delete    # Use HTTP DELETE method instead
GET    /api/usersById/123   # Redundant, use /api/users/123
                </div>

                <h3>HTTP Status Codes</h3>
                <div class="code-block">
                    <div class="code-header">Common HTTP Status Codes for APIs</div>
// 2xx Success
200 OK                    # Request successful
201 Created             # Resource created successfully
204 No Content          # Request successful, no content returned

// 3xx Redirection
301 Moved Permanently   # Resource moved permanently
302 Found              # Resource found at different location
304 Not Modified       # Resource not modified since last request

// 4xx Client Error
400 Bad Request         # Invalid request data
401 Unauthorized        # Authentication required
403 Forbidden          # Access denied
404 Not Found          # Resource not found
409 Conflict           # Resource conflict (e.g., duplicate)
422 Unprocessable Entity # Validation failed
429 Too Many Requests  # Rate limit exceeded

// 5xx Server Error
500 Internal Server Error # Unexpected server error
502 Bad Gateway        # Invalid response from upstream server
503 Service Unavailable # Server temporarily unavailable
504 Gateway Timeout    # Server timeout
                </div>
            </div>

            <div class="section">
                <h2>üìã API Documentation with Swagger/OpenAPI</h2>
                <p>API documentation is crucial for developers to understand and use your API effectively. Swagger/OpenAPI provides a standard way to document REST APIs.</p>

                <h3>Setting Up Swagger</h3>
                <div class="code-block">
                    <div class="code-header">Installing Swagger Dependencies</div>
# Install swagger packages
npm install swagger-jsdoc swagger-ui-express

# For TypeScript support
npm install --save-dev @types/swagger-jsdoc @types/swagger-ui-express
                </div>

                <div class="code-block">
                    <div class="code-header">Swagger Configuration</div>
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

// Swagger definition
const swaggerDefinition = {
    openapi: '3.0.0',
    info: {
        title: 'User Management API',
        version: '1.0.0',
        description: 'A comprehensive API for user management',
        contact: {
            name: 'API Support',
            email: 'support@yourapi.com'
        },
        license: {
            name: 'MIT',
            url: 'https://opensource.org/licenses/MIT'
        }
    },
    servers: [
        {
            url: 'http://localhost:3000/api',
            description: 'Development server'
        },
        {
            url: 'https://api.yourapp.com',
            description: 'Production server'
        }
    ],
    components: {
        securitySchemes: {
            bearerAuth: {
                type: 'http',
                scheme: 'bearer',
                bearerFormat: 'JWT'
            },
            apiKeyAuth: {
                type: 'apiKey',
                in: 'header',
                name: 'X-API-Key'
            }
        },
        schemas: {
            User: {
                type: 'object',
                required: ['username', 'email', 'password'],
                properties: {
                    id: {
                        type: 'string',
                        description: 'Unique identifier for the user'
                    },
                    username: {
                        type: 'string',
                        minLength: 3,
                        maxLength: 50,
                        description: 'Unique username'
                    },
                    email: {
                        type: 'string',
                        format: 'email',
                        description: 'User email address'
                    },
                    role: {
                        type: 'string',
                        enum: ['user', 'admin', 'moderator'],
                        default: 'user',
                        description: 'User role'
                    },
                    isActive: {
                        type: 'boolean',
                        default: true,
                        description: 'Account status'
                    },
                    createdAt: {
                        type: 'string',
                        format: 'date-time',
                        description: 'Account creation timestamp'
                    }
                }
            },
            Error: {
                type: 'object',
                properties: {
                    success: {
                        type: 'boolean',
                        example: false
                    },
                    error: {
                        type: 'string',
                        description: 'Error message'
                    },
                    code: {
                        type: 'string',
                        description: 'Error code'
                    }
                }
            }
        }
    },
    security: [
        {
            bearerAuth: []
        }
    ]
};

// Options for swagger-jsdoc
const options = {
    swaggerDefinition,
    apis: ['./routes/*.js', './controllers/*.js'] // Paths to files containing OpenAPI definitions
};

// Initialize swagger-jsdoc
const swaggerSpec = swaggerJsdoc(options);

module.exports = { swaggerUi, swaggerSpec };
                </div>

                <h3>Documenting API Endpoints</h3>
                <div class="code-block">
                    <div class="code-header">Documenting API Routes with Swagger Annotations</div>
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

/**
 * @swagger
 * /users:
 *   get:
 *     summary: Get all users
 *     description: Retrieve a list of all users with optional filtering and pagination
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: role
 *         schema:
 *           type: string
 *           enum: [user, admin, moderator]
 *         description: Filter users by role
 *     responses:
 *       200:
 *         description: List of users retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 *                 pagination:
 *                   type: object
 *                   properties:
 *                     currentPage:
 *                       type: integer
 *                     totalPages:
 *                       type: integer
 *                     totalUsers:
 *                       type: integer
 *                     hasNext:
 *                       type: boolean
 *                     hasPrev:
 *                       type: boolean
 *       401:
 *         description: Unauthorized - Authentication required
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.get('/users', authenticateToken, async (req, res) => {
    // Implementation here
});

/**
 * @swagger
 * /users:
 *   post:
 *     summary: Create a new user
 *     description: Register a new user account
 *     tags: [Users]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *             properties:
 *               username:
 *                 type: string
 *                 minLength: 3
 *                 maxLength: 50
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 8
 *               role:
 *                 type: string
 *                 enum: [user, admin, moderator]
 *                 default: user
 *     responses:
 *       201:
 *         description: User created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/User'
 *       400:
 *         description: Validation error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       409:
 *         description: User already exists
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.post('/users', async (req, res) => {
    // Implementation here
});

/**
 * @swagger
 * /users/{id}:
 *   get:
 *     summary: Get user by ID
 *     description: Retrieve a specific user by their ID
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *     responses:
 *       200:
 *         description: User retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/User'
 *       404:
 *         description: User not found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.get('/users/:id', authenticateToken, async (req, res) => {
    // Implementation here
});

module.exports = router;
                </div>

                <h3>Setting Up Swagger UI</h3>
                <div class="code-block">
                    <div class="code-header">Integrating Swagger UI with Express</div>
const express = require('express');
const { swaggerUi, swaggerSpec } = require('./config/swagger');

const app = express();

// Swagger UI setup
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
    explorer: true,
    swaggerOptions: {
        docExpansion: 'none',
        filter: true,
        showRequestDuration: true,
        syntaxHighlight: {
            activate: true,
            theme: 'arta'
        },
        tryItOutEnabled: true,
        requestInterceptor: (req) => {
            // Add authorization header if token exists
            const token = req.headers.Authorization || localStorage.getItem('token');
            if (token) {
                req.headers.Authorization = `Bearer ${token}`;
            }
            return req;
        }
    }
}));

// Custom CSS for Swagger UI
app.use('/api-docs', express.static('public/swagger'));

// API routes
app.use('/api', require('./routes/users'));
app.use('/api', require('./routes/posts'));

// Redirect root to API docs
app.get('/', (req, res) => {
    res.redirect('/api-docs');
});

app.listen(3000, () => {
    console.log('Server running on http://localhost:3000');
    console.log('API Documentation: http://localhost:3000/api-docs');
});
                </div>
            </div>

            <div class="section">
                <h2>üîç API Testing and Validation</h2>
                <p>Comprehensive API testing ensures your endpoints work correctly and handle edge cases properly.</p>

                <h3>Setting Up Testing Framework</h3>
                <div class="code-block">
                    <div class="code-header">Installing Testing Dependencies</div>
# Install testing framework
npm install --save-dev jest supertest

# For additional testing utilities
npm install --save-dev cross-env mongodb-memory-server

# For API contract testing
npm install --save-dev pactum
                </div>

                <h3>Unit Tests for API Logic</h3>
                <div class="code-block">
                    <div class="code-header">Unit Tests with Jest</div>
// tests/unit/userService.test.js
const UserService = require('../../services/UserService');
const User = require('../../models/User');

jest.mock('../../models/User');

describe('UserService', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    describe('createUser', () => {
        it('should create a user successfully', async () => {
            const userData = {
                username: 'testuser',
                email: 'test@example.com',
                password: 'password123'
            };

            const mockUser = {
                ...userData,
                _id: 'user123',
                save: jest.fn().mockResolvedValue({
                    ...userData,
                    _id: 'user123'
                })
            };

            User.mockImplementation(() => mockUser);

            const result = await UserService.createUser(userData);

            expect(result).toHaveProperty('_id', 'user123');
            expect(result.username).toBe(userData.username);
            expect(mockUser.save).toHaveBeenCalled();
        });

        it('should throw error for invalid email', async () => {
            const userData = {
                username: 'testuser',
                email: 'invalid-email',
                password: 'password123'
            };

            await expect(UserService.createUser(userData))
                .rejects
                .toThrow('Invalid email format');
        });

        it('should throw error for weak password', async () => {
            const userData = {
                username: 'testuser',
                email: 'test@example.com',
                password: '123'
            };

            await expect(UserService.createUser(userData))
                .rejects
                .toThrow('Password does not meet requirements');
        });
    });

    describe('findUserByEmail', () => {
        it('should find user by email', async () => {
            const mockUser = {
                _id: 'user123',
                email: 'test@example.com',
                username: 'testuser'
            };

            User.findOne.mockResolvedValue(mockUser);

            const result = await UserService.findUserByEmail('test@example.com');

            expect(result).toEqual(mockUser);
            expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
        });

        it('should return null if user not found', async () => {
            User.findOne.mockResolvedValue(null);

            const result = await UserService.findUserByEmail('nonexistent@example.com');

            expect(result).toBeNull();
        });
    });
});
                </div>

                <h3>Integration Tests for API Endpoints</h3>
                <div class="code-block">
                    <div class="code-header">Integration Tests with Supertest</div>
// tests/integration/auth.test.js
const request = require('supertest');
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const app = require('../../app');
const User = require('../../models/User');

let mongoServer;

beforeAll(async () => {
    // Start in-memory MongoDB instance
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();
    await mongoose.connect(mongoUri);
});

afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
});

beforeEach(async () => {
    // Clear database before each test
    await User.deleteMany({});
});

describe('Authentication API', () => {
    describe('POST /api/auth/register', () => {
        it('should register a new user successfully', async () => {
            const userData = {
                username: 'testuser',
                email: 'test@example.com',
                password: 'Password123!'
            };

            const response = await request(app)
                .post('/api/auth/register')
                .send(userData)
                .expect(201);

            expect(response.body.success).toBe(true);
            expect(response.body.data).toHaveProperty('_id');
            expect(response.body.data.username).toBe(userData.username);
            expect(response.body.data.email).toBe(userData.email);
            expect(response.body.data).not.toHaveProperty('password');
        });

        it('should return 400 for invalid data', async () => {
            const invalidData = {
                username: 'tu', // Too short
                email: 'invalid-email',
                password: '123' // Too weak
            };

            const response = await request(app)
                .post('/api/auth/register')
                .send(invalidData)
                .expect(400);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBeDefined();
        });

        it('should return 409 for duplicate email', async () => {
            // Create first user
            await User.create({
                username: 'user1',
                email: 'test@example.com',
                password: 'hashedpassword'
            });

            // Try to create user with same email
            const duplicateData = {
                username: 'user2',
                email: 'test@example.com',
                password: 'Password123!'
            };

            const response = await request(app)
                .post('/api/auth/register')
                .send(duplicateData)
                .expect(409);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toContain('already exists');
        });
    });

    describe('POST /api/auth/login', () => {
        beforeEach(async () => {
            // Create test user
            await User.create({
                username: 'testuser',
                email: 'test@example.com',
                password: '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj6fYzYX5Qy' // 'password123'
            });
        });

        it('should login successfully with correct credentials', async () => {
            const loginData = {
                email: 'test@example.com',
                password: 'password123'
            };

            const response = await request(app)
                .post('/api/auth/login')
                .send(loginData)
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data).toHaveProperty('accessToken');
            expect(response.body.data).toHaveProperty('user');
            expect(response.body.data.user.email).toBe(loginData.email);
        });

        it('should return 401 for incorrect password', async () => {
            const loginData = {
                email: 'test@example.com',
                password: 'wrongpassword'
            };

            const response = await request(app)
                .post('/api/auth/login')
                .send(loginData)
                .expect(401);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Invalid credentials');
        });

        it('should return 401 for non-existent user', async () => {
            const loginData = {
                email: 'nonexistent@example.com',
                password: 'password123'
            };

            const response = await request(app)
                .post('/api/auth/login')
                .send(loginData)
                .expect(401);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Invalid credentials');
        });
    });

    describe('GET /api/auth/profile', () => {
        let accessToken;

        beforeEach(async () => {
            // Create test user and get token
            const user = await User.create({
                username: 'testuser',
                email: 'test@example.com',
                password: 'hashedpassword'
            });

            // Mock JWT token generation for testing
            accessToken = 'mock-jwt-token-for-user-' + user._id;
        });

        it('should return user profile with valid token', async () => {
            const response = await request(app)
                .get('/api/auth/profile')
                .set('Authorization', `Bearer ${accessToken}`)
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.data).toHaveProperty('username', 'testuser');
            expect(response.body.data).toHaveProperty('email', 'test@example.com');
        });

        it('should return 401 without token', async () => {
            const response = await request(app)
                .get('/api/auth/profile')
                .expect(401);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Access token required');
        });

        it('should return 403 with invalid token', async () => {
            const response = await request(app)
                .get('/api/auth/profile')
                .set('Authorization', 'Bearer invalid-token')
                .expect(403);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBe('Invalid access token');
        });
    });
});
                </div>

                <h3>API Contract Testing</h3>
                <div class="code-block">
                    <div class="code-header">API Contract Tests with Pactum</div>
// tests/contract/api.contract.test.js
const pactum = require('pactum');

describe('API Contract Tests', () => {
    beforeAll(() => {
        // Set base URL for all tests
        pactum.request.setBaseUrl('http://localhost:3000/api');
    });

    describe('Users API', () => {
        let createdUserId;
        let authToken;

        it('should register a new user', async () => {
            await pactum.spec()
                .post('/auth/register')
                .withJson({
                    username: 'contractuser',
                    email: 'contract@example.com',
                    password: 'ContractPass123!'
                })
                .expectStatus(201)
                .expectJsonLike({
                    success: true,
                    data: {
                        username: 'contractuser',
                        email: 'contract@example.com'
                    }
                })
                .stores('userId', 'data._id')
                .toss();

            createdUserId = pactum.stash.getDataStore()['userId'];
        });

        it('should login and get access token', async () => {
            await pactum.spec()
                .post('/auth/login')
                .withJson({
                    email: 'contract@example.com',
                    password: 'ContractPass123!'
                })
                .expectStatus(200)
                .expectJsonLike({
                    success: true,
                    data: {
                        accessToken: /\w+/,
                        user: {
                            email: 'contract@example.com'
                        }
                    }
                })
                .stores('accessToken', 'data.accessToken')
                .toss();

            authToken = pactum.stash.getDataStore()['accessToken'];
        });

        it('should get user profile', async () => {
            await pactum.spec()
                .get('/auth/profile')
                .withHeaders({
                    'Authorization': `Bearer ${authToken}`
                })
                .expectStatus(200)
                .expectJsonLike({
                    success: true,
                    data: {
                        username: 'contractuser',
                        email: 'contract@example.com'
                    }
                })
                .toss();
        });

        it('should get user by ID', async () => {
            await pactum.spec()
                .get('/users/{userId}')
                .withPathParams('userId', createdUserId)
                .withHeaders({
                    'Authorization': `Bearer ${authToken}`
                })
                .expectStatus(200)
                .expectJsonLike({
                    success: true,
                    data: {
                        _id: createdUserId,
                        username: 'contractuser'
                    }
                })
                .toss();
        });

        it('should update user', async () => {
            await pactum.spec()
                .put('/users/{userId}')
                .withPathParams('userId', createdUserId)
                .withHeaders({
                    'Authorization': `Bearer ${authToken}`
                })
                .withJson({
                    username: 'updateduser'
                })
                .expectStatus(200)
                .expectJsonLike({
                    success: true,
                    data: {
                        username: 'updateduser'
                    }
                })
                .toss();
        });

        it('should delete user', async () => {
            await pactum.spec()
                .delete('/users/{userId}')
                .withPathParams('userId', createdUserId)
                .withHeaders({
                    'Authorization': `Bearer ${authToken}`
                })
                .expectStatus(200)
                .expectJsonLike({
                    success: true
                })
                .toss();
        });

        it('should return 404 for deleted user', async () => {
            await pactum.spec()
                .get('/users/{userId}')
                .withPathParams('userId', createdUserId)
                .withHeaders({
                    'Authorization': `Bearer ${authToken}`
                })
                .expectStatus(404)
                .expectJsonLike({
                    success: false,
                    error: 'User not found'
                })
                .toss();
        });
    });

    describe('Error Handling', () => {
        it('should handle validation errors', async () => {
            await pactum.spec()
                .post('/auth/register')
                .withJson({
                    username: '',
                    email: 'invalid-email',
                    password: '123'
                })
                .expectStatus(400)
                .expectJsonLike({
                    success: false,
                    error: /\w+/
                })
                .toss();
        });

        it('should handle unauthorized access', async () => {
            await pactum.spec()
                .get('/users')
                .expectStatus(401)
                .expectJsonLike({
                    success: false,
                    error: 'Access token required'
                })
                .toss();
        });

        it('should handle not found resources', async () => {
            await pactum.spec()
                .get('/users/nonexistent-id')
                .withHeaders({
                    'Authorization': 'Bearer mock-token'
                })
                .expectStatus(404)
                .expectJsonLike({
                    success: false,
                    error: 'User not found'
                })
                .toss();
        });
    });
});
                </div>
            </div>

            <div class="section">
                <h2>üöÄ API Deployment and Production</h2>
                <p>Deploying APIs to production requires careful consideration of performance, scalability, and monitoring.</p>

                <h3>Environment Configuration</h3>
                <div class="code-block">
                    <div class="code-header">Production Environment Setup</div>
# .env.production
NODE_ENV=production
PORT=3000
HOST=0.0.0.0

# Database
DATABASE_URL=postgresql://user:password@prod-db-host:5432/prod_db
DB_POOL_MIN=5
DB_POOL_MAX=20

# Redis (for caching and sessions)
REDIS_URL=redis://prod-redis-host:6379

# JWT
JWT_SECRET=your-production-jwt-secret-key-very-long-and-secure
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d

# CORS
CORS_ORIGIN=https://yourapp.com,https://www.yourapp.com

# Rate Limiting
RATE_LIMIT_WINDOW=15
RATE_LIMIT_MAX_REQUESTS=100

# Logging
LOG_LEVEL=info
LOG_FILE=/var/log/yourapp/app.log

# Monitoring
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
NEW_RELIC_LICENSE_KEY=your-new-relic-license-key

# Email
SMTP_HOST=smtp.your-email-provider.com
SMTP_PORT=587
SMTP_USER=your-email@yourapp.com
SMTP_PASS=your-email-password
                </div>

                <h3>Process Management with PM2</h3>
                <div class="code-block">
                    <div class="code-header">PM2 Configuration for Production</div>
# Install PM2 globally
npm install -g pm2

# ecosystem.config.js
module.exports = {
  apps: [{
    name: 'api-server',
    script: 'server.js',
    instances: 'max', // Use all available CPU cores
    exec_mode: 'cluster', // Enable cluster mode
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    // Logging
    log_file: '/var/log/yourapp/combined.log',
    out_file: '/var/log/yourapp/out.log',
    error_file: '/var/log/yourapp/error.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
    // Process management
    max_memory_restart: '1G', // Restart if memory usage exceeds 1GB
    restart_delay: 4000, // Delay between restarts
    // Health checks
    health_check: {
      enabled: true,
      url: '/health',
      interval: 30000, // Check every 30 seconds
      timeout: 5000, // Timeout after 5 seconds
      unhealthy_threshold: 3, // Mark unhealthy after 3 failures
      healthy_threshold: 2 // Mark healthy after 2 successes
    },
    // Auto restart on file changes (disable in production)
    watch: false,
    // Environment variables
    env_file: '.env.production'
  }]
};
                </div>

                <h3>API Monitoring and Logging</h3>
                <div class="code-block">
                    <div class="code-header">Comprehensive Logging Setup</div>
const winston = require('winston');
const expressWinston = require('express-winston');

// Create logger instance
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api-server' },
  transports: [
    // Write all logs with importance level of `error` or less to `error.log`
    new winston.transports.File({
      filename: process.env.ERROR_LOG_FILE || 'logs/error.log',
      level: 'error'
    }),
    // Write all logs with importance level of `info` or less to `combined.log`
    new winston.transports.File({
      filename: process.env.COMBINED_LOG_FILE || 'logs/combined.log'
    })
  ]
});

// If we're not in production, log to the console with a simple format
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

// Request logging middleware
const requestLogger = expressWinston.logger({
  winstonInstance: logger,
  meta: true, // Log metadata about request
  msg: 'HTTP {{req.method}} {{req.url}} {{res.statusCode}} {{res.responseTime}}ms',
  expressFormat: true,
  colorize: false,
  ignoreRoute: function (req, res) {
    return req.url === '/health'; // Don't log health checks
  }
});

// Error logging middleware
const errorLogger = expressWinston.errorLogger({
  winstonInstance: logger
});

// Custom logging functions
const logAPIRequest = (req, res, next) => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    const logData = {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
      userAgent: req.get('User-Agent'),
      ip: req.ip,
      userId: req.user ? req.user.userId : null
    };

    if (res.statusCode >= 400) {
      logger.warn('API Request Warning', logData);
    } else {
      logger.info('API Request', logData);
    }
  });

  next();
};

module.exports = {
  logger,
  requestLogger,
  errorLogger,
  logAPIRequest
};
                </div>

                <h3>API Performance Optimization</h3>
                <div class="code-block">
                    <div class="code-header">Caching and Performance Middleware</div>
const redis = require('redis');
const responseTime = require('response-time');
const compression = require('compression');

// Redis client for caching
const redisClient = redis.createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379'
});

redisClient.on('error', (err) => {
  console.error('Redis Client Error', err);
});

redisClient.connect();

// Response time middleware
const responseTimeMiddleware = responseTime((req, res, time) => {
  if (time > 1000) { // Log slow requests (> 1 second)
    console.warn(`Slow request: ${req.method} ${req.url} took ${time}ms`);
  }
});

// Compression middleware
const compressionMiddleware = compression({
  level: 6, // Compression level (1-9)
  threshold: 1024, // Only compress responses larger than 1KB
  filter: (req, res) => {
    // Don't compress responses with this request header
    if (req.headers['x-no-compression']) {
      return false;
    }
    // Use compression filter function
    return compression.filter(req, res);
  }
});

// Caching middleware
const cacheMiddleware = (duration) => {
  return async (req, res, next) => {
    if (req.method !== 'GET') {
      return next();
    }

    const key = `cache:${req.originalUrl}`;

    try {
      const cachedResponse = await redisClient.get(key);

      if (cachedResponse) {
        res.set('X-Cache', 'HIT');
        return res.json(JSON.parse(cachedResponse));
      }

      // Store original json method
      const originalJson = res.json;

      // Override json method to cache response
      res.json = function(data) {
        redisClient.setEx(key, duration, JSON.stringify(data));
        res.set('X-Cache', 'MISS');
        return originalJson.call(this, data);
      };

      next();
    } catch (error) {
      console.error('Cache middleware error:', error);
      next();
    }
  };
};

// Clear cache for specific patterns
const clearCache = async (pattern) => {
  try {
    const keys = await redisClient.keys(pattern);
    if (keys.length > 0) {
      await redisClient.del(keys);
      console.log(`Cleared ${keys.length} cache entries for pattern: ${pattern}`);
    }
  } catch (error) {
    console.error('Clear cache error:', error);
  }
};

// Database query result caching
const queryCache = {
  get: async (key) => {
    try {
      const data = await redisClient.get(`query:${key}`);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Query cache get error:', error);
      return null;
    }
  },

  set: async (key, data, ttl = 300) => { // Default 5 minutes TTL
    try {
      await redisClient.setEx(`query:${key}`, ttl, JSON.stringify(data));
    } catch (error) {
      console.error('Query cache set error:', error);
    }
  },

  invalidate: async (key) => {
    try {
      await redisClient.del(`query:${key}`);
    } catch (error) {
      console.error('Query cache invalidate error:', error);
    }
  }
};

module.exports = {
  responseTimeMiddleware,
  compressionMiddleware,
  cacheMiddleware,
  clearCache,
  queryCache,
  redisClient
};
                </div>
            </div>

            <div class="practice-exercise">
                <h4>üõ†Ô∏è Practice Exercise: Complete API Development</h4>
                <p>Build a complete production-ready API with the following features:</p>
                <ul>
                    <li><strong>RESTful Design:</strong> Proper HTTP methods, status codes, and resource naming</li>
                    <li><strong>Documentation:</strong> Complete Swagger/OpenAPI documentation</li>
                    <li><strong>Testing:</strong> Unit tests, integration tests, and contract tests</li>
                    <li><strong>Authentication:</strong> JWT-based authentication with refresh tokens</li>
                    <li><strong>Validation:</strong> Input validation and error handling</li>
                    <li><strong>Caching:</strong> Redis-based response and query caching</li>
                    <li><strong>Monitoring:</strong> Comprehensive logging and error tracking</li>
                    <li><strong>Performance:</strong> Compression, rate limiting, and optimization</li>
                    <li><strong>Deployment:</strong> PM2 configuration and production setup</li>
                </ul>
                <p><strong>Requirements:</strong></p>
                <ul>
                    <li>Implement proper error handling with custom error classes</li>
                    <li>Add request/response logging with Winston</li>
                    <li>Implement rate limiting for API endpoints</li>
                    <li>Add health check endpoints for monitoring</li>
                    <li>Configure CORS properly for production</li>
                    <li>Set up environment-based configuration</li>
                    <li>Add API versioning strategy</li>
                    <li>Implement graceful shutdown handling</li>
                    <li>Add database connection pooling</li>
                    <li>Configure security headers and middleware</li>
                </ul>
            </div>

            <div class="quiz">
                <h4>üìù Knowledge Check</h4>
                <ol>
                    <li>What are the key principles of RESTful API design?</li>
                    <li>How do you properly document API endpoints using OpenAPI/Swagger?</li>
                    <li>What is the difference between unit tests and integration tests for APIs?</li>
                    <li>How do you implement caching in a Node.js API application?</li>
                    <li>What are the benefits of using PM2 for production deployments?</li>
                    <li>How do you handle API versioning in RESTful services?</li>
                    <li>What are some common performance optimization techniques for APIs?</li>
                    <li>How do you implement proper error handling and logging in production?</li>
                </ol>
            </div>

            <div class="summary">
                <h3>üìö Chapter Summary</h3>
                <div class="key-points">
                    <div class="key-point">
                        <h5>üåê RESTful API Design</h5>
                        <p>Proper HTTP methods, status codes, resource naming, and REST principles for building scalable APIs.</p>
                    </div>
                    <div class="key-point">
                        <h5>üìã API Documentation</h5>
                        <p>Complete Swagger/OpenAPI documentation with interactive UI for developers to understand and test APIs.</p>
                    </div>
                    <div class="key-point">
                        <h5>üîç Testing & Validation</h5>
                        <p>Comprehensive testing strategy including unit tests, integration tests, and API contract testing.</p>
                    </div>
                    <div class="key-point">
                        <h5>üöÄ Production Deployment</h5>
                        <p>PM2 process management, environment configuration, and production-ready deployment strategies.</p>
                    </div>
                    <div class="key-point">
                        <h5>üìä Monitoring & Logging</h5>
                        <p>Comprehensive logging with Winston, error tracking, and performance monitoring for production applications.</p>
                    </div>
                    <div class="key-point">
                        <h5>‚ö° Performance Optimization</h5>
                        <p>Caching strategies, compression, rate limiting, and database optimization for high-performance APIs.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>